<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yancechen.github.io</id>
    <title>陈有余</title>
    <updated>2020-11-24T07:22:13.512Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yancechen.github.io"/>
    <link rel="self" href="https://yancechen.github.io/atom.xml"/>
    <subtitle>万物之中，希望至美</subtitle>
    <logo>https://yancechen.github.io/images/avatar.png</logo>
    <icon>https://yancechen.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 陈有余</rights>
    <entry>
        <title type="html"><![CDATA[使用 Jetpack 组件构建 MVVM 应用程序]]></title>
        <id>https://yancechen.github.io/post/shi-yong-jetpack-zu-jian-gou-jian-mvvm-ying-yong-cheng-xu/</id>
        <link href="https://yancechen.github.io/post/shi-yong-jetpack-zu-jian-gou-jian-mvvm-ying-yong-cheng-xu/">
        </link>
        <updated>2020-11-24T07:21:39.000Z</updated>
        <content type="html"><![CDATA[<p>本文会为大家演示通过 Jetpack 组件搭建一个 MVVM 架构的应用程序。需求很简单，就是请求一个接口，然后获取几个字段的数据显示到页面上。</p>
<p>接口我们使用 GitHub 开放的 API：</p>
<pre><code>https://api.github.com/users/{login}
</code></pre>
<p>login 是 GitHub 的用户名</p>
<p>为了用最简单的案例为大家说清楚什么是 MVVM 以及什么是数据模型驱动视图更新，我们只使用 Jetpack 的其中几个组件，分别是</p>
<ul>
<li>LiveData</li>
<li>Room</li>
<li>ViewModel</li>
<li>DataBinding</li>
</ul>
<p>而对于 LifeCycle、Navigation、Paging 等组件可以根据具体业务场景需要的时候再添加。</p>
<h1 id="1最终效果图">1.最终效果图</h1>
<figure data-type="image" tabindex="1"><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5ead42e125c40f2a5a45240f79cf979~tplv-k3u1fbpfcp-watermark.image" alt="最终效果图" loading="lazy"></figure>
<p>需要展示的元素包括：</p>
<ol>
<li>用户头像（avatar）</li>
<li>用户真实姓名（name）</li>
<li>个人签名（bio）</li>
<li>所在地区（location）</li>
<li>关注者（followers）</li>
<li>正在关注（following）</li>
<li>github 地址（html_url）</li>
<li>个人博客地址（blog）</li>
</ol>
<p>项目的需求比较简单，但是也涉及一些细微的知识点，我们在后面 coding 演示时会详细说明。</p>
<h1 id="2api-说明">2.API 说明</h1>
<p>获取 GitHub 个人信息</p>
<h2 id="21-base_url">2.1 base_url</h2>
<pre><code>https://api.github.com/
</code></pre>
<h2 id="22-path">2.2 path</h2>
<pre><code>users/{login}
</code></pre>
<p>login 是 GitHub 的用户名。</p>
<h2 id="23-json-数据">2.3 json 数据</h2>
<pre><code class="language-json">{
	&quot;login&quot;: &quot;yancechen&quot;,
	&quot;id&quot;: 19751111,
	&quot;node_id&quot;: &quot;MDQ6VXN******NzU3NzI4&quot;,
	&quot;avatar_url&quot;: &quot;******&quot;,
	&quot;gravatar_id&quot;: &quot;&quot;,
	&quot;url&quot;: &quot;******&quot;,,
	&quot;html_url&quot;: &quot;******&quot;,
	&quot;followers_url&quot;: &quot;******&quot;,
	&quot;following_url&quot;: &quot;******&quot;,
	&quot;gists_url&quot;: &quot;******&quot;,
	&quot;starred_url&quot;: &quot;******&quot;,
	&quot;subscriptions_url&quot;: &quot;******&quot;,
	&quot;organizations_url&quot;: &quot;******&quot;,
	&quot;repos_url&quot;: &quot;******&quot;,
	&quot;events_url&quot;: &quot;******&quot;,
	&quot;received_events_url&quot;: &quot;******&quot;,
	&quot;type&quot;: &quot;User&quot;,
	&quot;site_admin&quot;: false,
	&quot;name&quot;: &quot;陈有余&quot;,
	&quot;company&quot;: null,
	&quot;blog&quot;: &quot;******&quot;,
	&quot;location&quot;: &quot;北京&quot;,
	&quot;email&quot;: null,
	&quot;hireable&quot;: null,
	&quot;bio&quot;: &quot;万物之中，希望至美&quot;,
	&quot;twitter_username&quot;: null,
	&quot;public_repos&quot;: 35,
	&quot;public_gists&quot;: 0,
	&quot;followers&quot;: 7,
	&quot;following&quot;: 22,
	&quot;created_at&quot;: &quot;2016-06-05T07:06:41Z&quot;,
	&quot;updated_at&quot;: &quot;2020-10-30T06:45:52Z&quot;
}
</code></pre>
<h1 id="3项目工程结构">3.项目工程结构</h1>
<figure data-type="image" tabindex="2"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96828519213f43438a577006d5ec2290~tplv-k3u1fbpfcp-watermark.image" alt="工程结构图" loading="lazy"></figure>
<p>结合上面的工程结构图，我们可以大致将项目分为一下几个层级：</p>
<ul>
<li>
<p>Model：我们采用 Room 数据库来存储用户个人信息。</p>
</li>
<li>
<p>API（也可以叫 http 层或者 net 层）：通过 Retrofit 请求 GitHub API。</p>
</li>
<li>
<p>Application：在其中实例化 Room 和 Retrofit 对象，以便统一管理和全局调用。</p>
</li>
<li>
<p>Repository：用来处理 API 网络请求获取网络数据、 Room 数据库数据的处理以及处理网络数据和 Room 数据之间的业务关系。注意，项目里面不一定非得引入 Room 数据库，如果不使用 Room 的话，Repository 层中只负责处理网络数据即可。</p>
</li>
<li>
<p>ViewModel：从 Repository 层中获取数据，ViewModel 不需要关心数据的来源是 Room 还是 API 接口。</p>
</li>
<li>
<p>View：也就是我们熟悉的 Activity/Fragment 和布局文件。我们会在 View 层中使用 DataBinding 组件。</p>
</li>
</ul>
<p>下面，我们会结合代码来分别对每一层进行说明。</p>
<h1 id="4代码演示">4.代码演示</h1>
<h2 id="41-准备工作">4.1 准备工作</h2>
<h3 id="411-添加网络权限">4.1.1 添加网络权限</h3>
<pre><code class="language-XML">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;
</code></pre>
<h3 id="412-添加依赖">4.1.2 添加依赖</h3>
<p>a.在添加的依赖中除了 Jetpack 相关的组件，我们还需要引入 Retrofit、Glide、下拉刷新组件：</p>
<pre><code class="language-groovy">//Room
def room_version = &quot;2.2.5&quot;
implementation &quot;androidx.room:room-runtime:$room_version&quot;
annotationProcessor &quot;androidx.room:room-compiler:$room_version&quot;

//ViewModel
def lifecycle_version = &quot;2.2.0&quot;
implementation &quot;androidx.lifecycle:lifecycle-viewmodel:$lifecycle_version&quot;

//Retrofit
implementation 'com.squareup.retrofit2:retrofit:2.9.0'
implementation 'com.squareup.retrofit2:converter-gson:2.5.0'
    
//图片加载
implementation 'com.github.bumptech.glide:glide:4.11.0'
annotationProcessor 'com.github.bumptech.glide:compiler:4.11.0'
    
//下拉刷新
implementation &quot;androidx.swiperefreshlayout:swiperefreshlayout:1.1.0&quot;
</code></pre>
<p>b.我们还需要在 app 的 build.gradle 文件中开启 DataBinding：</p>
<pre><code>android {
    ...

    buildFeatures {
        dataBinding true
    }
}
</code></pre>
<p>c.使用 Java 8</p>
<pre><code class="language-groovy">compileOptions {
    sourceCompatibility JavaVersion.VERSION_1_8
    targetCompatibility JavaVersion.VERSION_1_8
}
</code></pre>
<p>整体的 build.gradle 文件如下</p>
<pre><code class="language-groovy">apply plugin: 'com.android.application'

android {
    compileSdkVersion 29
    buildToolsVersion &quot;30.0.0&quot;

    defaultConfig {
        applicationId &quot;com.yance&quot;
        minSdkVersion 21
        targetSdkVersion 29
        versionCode 1
        versionName &quot;1.0&quot;

        testInstrumentationRunner &quot;androidx.test.runner.AndroidJUnitRunner&quot;
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }

    buildFeatures {
        dataBinding true
    }
}

dependencies {
    implementation fileTree(dir: &quot;libs&quot;, include: [&quot;*.jar&quot;])
    implementation 'androidx.appcompat:appcompat:1.2.0'
    implementation 'androidx.constraintlayout:constraintlayout:2.0.2'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'androidx.test.ext:junit:1.1.2'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.3.0'

    //Room
    def room_version = &quot;2.2.5&quot;
    implementation &quot;androidx.room:room-runtime:$room_version&quot;
    annotationProcessor &quot;androidx.room:room-compiler:$room_version&quot;

    //ViewModel
    def lifecycle_version = &quot;2.2.0&quot;
    implementation &quot;androidx.lifecycle:lifecycle-viewmodel:$lifecycle_version&quot;

    //Retrofit
    implementation 'com.squareup.retrofit2:retrofit:2.9.0'
    implementation 'com.squareup.retrofit2:converter-gson:2.5.0'

    //图片加载
    implementation 'com.github.bumptech.glide:glide:4.11.0'
    annotationProcessor 'com.github.bumptech.glide:compiler:4.11.0'

    //下拉刷新
    implementation &quot;androidx.swiperefreshlayout:swiperefreshlayout:1.1.0&quot;
}
</code></pre>
<h2 id="42-model-层代码">4.2 Model 层代码</h2>
<h3 id="421-定义数据模型">4.2.1 定义数据模型</h3>
<p>因为我们是获取个人信息，因此我们命名为 User，在 User 模型中，我们只保留我们需要的字段：</p>
<pre><code class="language-java">@Entity(tableName = &quot;user&quot;)
public class User {

    @PrimaryKey
    @ColumnInfo(name = &quot;id&quot;, typeAffinity = ColumnInfo.INTEGER)
    public int id;

    @ColumnInfo(name = &quot;name&quot;, typeAffinity = ColumnInfo.TEXT)
    public String name;

    @ColumnInfo(name = &quot;login&quot;, typeAffinity = ColumnInfo.TEXT)
    public String login;

    @ColumnInfo(name = &quot;avatar&quot;, typeAffinity = ColumnInfo.TEXT)
    @SerializedName(&quot;avatar_url&quot;)
    public String avatar;

    @ColumnInfo(name = &quot;followers&quot;, typeAffinity = ColumnInfo.INTEGER)
    public int followers;

    @ColumnInfo(name = &quot;following&quot;, typeAffinity = ColumnInfo.INTEGER)
    public int following;

    @ColumnInfo(name = &quot;blog&quot;, typeAffinity = ColumnInfo.TEXT)
    public String blog;

    @ColumnInfo(name = &quot;bio&quot;, typeAffinity = ColumnInfo.TEXT)
    public String bio;

    @ColumnInfo(name = &quot;location&quot;, typeAffinity = ColumnInfo.TEXT)
    public String location;

    @ColumnInfo(name = &quot;html_url&quot;, typeAffinity = ColumnInfo.TEXT)
    @SerializedName(&quot;html_url&quot;)
    public String html_url;

    public User(int id, String name, String avatar, int followers, int following, String blog, String bio, String location, String html_url) {
        this.id = id;
        this.name = name;
        this.avatar = avatar;
        this.followers = followers;
        this.following = following;
        this.blog = blog;
        this.bio = bio;
        this.location = location;
        this.html_url = html_url;
    }
}
</code></pre>
<p>使用过数据库的同学应该对代码中的一些关键字不会感到陌生，基本都能见名知意。</p>
<ul>
<li>@Entity</li>
</ul>
<p>用于将 User 类与 Room 中的数据表对应起来。<code>tableName</code> 属性可以为数据表设置表名，若不设置，则表名与类名相同。</p>
<ul>
<li>@PrimaryKey</li>
</ul>
<p>用于指定该字段作为表的主键。</p>
<ul>
<li>@ColumnInfo</li>
</ul>
<p>设置该字段存储在数据库表中的名字，并指定字段的类型。</p>
<ul>
<li>@Ignore</li>
</ul>
<p>用来告诉 Room 忽略该字段或者方法。</p>
<p>由于 Room 只能识别和使用一个构造器，如果希望定义多个构造器，可以使用 @Ignore 标签，让 Room 忽略这个构造器。如果使用 @Ignore 标记字段的话，Room 就不会持久化该字段。</p>
<h3 id="422-创建数据库">4.2.2 创建数据库</h3>
<p>User 模型创建好以后，我们创建对应的 Room 数据库。</p>
<pre><code class="language-java">@Database(entities = {User.class}, version = 1)
public abstract class UserDatabase extends RoomDatabase {

    public static final String DATABASE_NAME = &quot;user_db1&quot;;

    private static UserDatabase databaseInstance;

    public static synchronized UserDatabase getInstance(Context context) {
        if (databaseInstance == null) {
            databaseInstance = Room.databaseBuilder(context.getApplicationContext(),
                    UserDatabase.class, DATABASE_NAME).build();
        }
        return databaseInstance;
    }

    public abstract UserDao userDao();
}
</code></pre>
<ul>
<li>@Database</li>
</ul>
<p>@Database 标签用于告诉系统这是 Room 数据库对象。<code>entities</code> 属性用于指定该数据库有哪些表，若需要建立多张表，则表名以逗号相隔开。<code>version</code> 属性用于指定数据库版本号，后面数据库的升级正是依据版本号进行判断的。</p>
<ul>
<li>RoomDatabase</li>
</ul>
<p>数据库类需要继承 <code>RoomDatabase</code>，并通过 <code>Room.databaseBuilder()</code> 结合单例设计模式完成创建。</p>
<p>我们看到最后一行代码是：</p>
<pre><code class="language-java">public abstract UserDao userDao();
</code></pre>
<p>这是声明操作数据库的 Dao（Data Access Objects） 文件，并且是以抽象的方式返回（这是一个固定的写法）。</p>
<p>UserDatabase 的职责只是创建数据库，如果想要访问数据库中的表，需要创建对应的 Dao 文件，并在 Dao 文件中提供增、删、改、查的方法。下面，我们创建一个 UserDao：</p>
<pre><code class="language-java">@Dao
public interface UserDao {

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    void insertUser(User user);

    @Delete
    void deleteStudent(User user);

    /**
     * 查询方式返回的是 LiveData 包装过的 User，这样当 Room 中的数据
     * 发生变化时，能够自动通知数据观察者
     *
     * @param login
     * @return
     */
    @Query(&quot;SELECT * FROM user WHERE login = :login&quot;)
    LiveData&lt;User&gt; getUserByName(String login);
}
</code></pre>
<p>注意，我们需要加上 <code>@Dao</code> 标签标记 UserDao。</p>
<p>增、删、改、查的方法分别使用 <code>@Insert</code>、<code>@Delete</code>、<code>@Update</code>、<code>@Query</code> 标签进行标记。</p>
<h2 id="43-api-层">4.3 API 层</h2>
<h3 id="431-定义-api-接口">4.3.1 定义 API 接口</h3>
<pre><code class="language-java">public interface Api {
    @GET(&quot;users/{login}&quot;)
    Call&lt;User&gt; getUser(@Path(&quot;login&quot;) String login);
}
</code></pre>
<h3 id="432-实例化-retrofit-对象">4.3.2 实例化 Retrofit 对象</h3>
<pre><code class="language-java">public class RetrofitClient {
    private static final String BASE_URL = &quot;https://api.github.com/&quot;;
    private static RetrofitClient retrofitClient;
    private Retrofit retrofit;

    private RetrofitClient() {
        OkHttpClient okHttpClient = new OkHttpClient.Builder()
                .sslSocketFactory(SSLSocketClient.getSSLSocketFactory())
                .hostnameVerifier(SSLSocketClient.getHostnameVerifier())
                .build();

        retrofit = new Retrofit.Builder().baseUrl(BASE_URL)
                .addConverterFactory(GsonConverterFactory.create())
                .client(okHttpClient)
                .build();
    }

    public static synchronized RetrofitClient getInstance() {
        if (retrofitClient == null) {
            retrofitClient = new RetrofitClient();
        }
        return retrofitClient;
    }

    public Api getApi() {
        return retrofit.create(Api.class);
    }
}
</code></pre>
<p>由于我们访问的是 <code>https</code> 的网站，为了访问方便，我们忽略掉 https 的证书验证。</p>
<pre><code class="language-java">OkHttpClient okHttpClient = new OkHttpClient.Builder()
                .sslSocketFactory(SSLSocketClient.getSSLSocketFactory())
                .hostnameVerifier(SSLSocketClient.getHostnameVerifier())
                .build();
</code></pre>
<p>SSLSocketClient 的源码如下：</p>
<pre><code class="language-java">public class SSLSocketClient {
    //获取这个SSLSocketFactory
    public static SSLSocketFactory getSSLSocketFactory() {
        try {
            SSLContext sslContext = SSLContext.getInstance(&quot;SSL&quot;);
            sslContext.init(null, getTrustManager(), new SecureRandom());
            return sslContext.getSocketFactory();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    //获取TrustManager
    private static TrustManager[] getTrustManager() {
        TrustManager[] trustAllCerts = new TrustManager[]{new X509TrustManager() {
            @Override
            public void checkClientTrusted(X509Certificate[] chain, String authType) {
            }

            @Override
            public void checkServerTrusted(X509Certificate[] chain, String authType) {
            }

            @Override
            public X509Certificate[] getAcceptedIssuers() {
                return new X509Certificate[]{};
            }
        }};
        return trustAllCerts;
    }

    //获取HostnameVerifier
    public static HostnameVerifier getHostnameVerifier() {
        HostnameVerifier hostnameVerifier = new HostnameVerifier() {
            @Override
            public boolean verify(String s, SSLSession sslSession) {
                return true;
            }
        };
        return hostnameVerifier;
    }
}
</code></pre>
<p>参考文章：<a href="https://www.cnblogs.com/huolongluo/p/8360478.html">Retrofit+OKHttp忽略https证书验证</a></p>
<h2 id="44-application-层">4.4 Application 层</h2>
<p>我们选择在 Application 中对 Room 和 Retrofit 进行实例化，这样做的好处是统一管理和全局调用这两个对象，并且不用担心这两个对象的生命周期问题，数据库和 Retrofit 对象通常伴随着整个应用程序的声明周期。</p>
<pre><code class="language-java">public class MyApplication extends Application {

    private static MyApplication instance;
    private static UserDatabase userDatabase;
    private static Api api;

    public MyApplication() {
        super();
        instance = this;
    }

    public static synchronized MyApplication getInstance() {
        return instance;
    }


    @Override
    public void onCreate() {
        super.onCreate();
        userDatabase = UserDatabase.getInstance(this);
        api = RetrofitClient.getInstance().getApi();
    }

    public static Api getApi() {
        return api;
    }

    public static UserDatabase getUserDatabase() {
        return userDatabase;
    }
}
</code></pre>
<h2 id="45-repository-层">4.5 Repository 层</h2>
<p>在该层中请求网络数据，并将得到的数据写入 Room 数据库。注意，在真实的项目中，不一定非要引入 Room 数据库，这里只是为了演示 Room 的使用，所有将网络数据写入了 Room 数据库中。</p>
<p>Repository 层只对 ViewModel 负责，它提供了两个方法 getUser() 和 refresh()。ViewModel 不需要关心数据是来自于网络还是本地数据库，当需要数据时，它只需要调用 getUser() 即可。</p>
<p>每次调用 getUser() 方法时，都会调用 refresh() 方法更新一次数据，refresh() 也被下拉刷新组件所调用。</p>
<p>当网络数据请求成功后，会直接将其写入数据库，由于使用了 LiveData，当数据有变化时，ViewModel 会自动得到通知，因此，你不用担心数据更新问题。</p>
<pre><code class="language-java">public class UserRepository {
    private String TAG = this.getClass().getName();
    private UserDao userDao;
    private Api api;

    public UserRepository(UserDao userDao, Api api) {
        this.userDao = userDao;
        this.api = api;
    }

    public LiveData&lt;User&gt; getUser(final String name) {
        refresh(name);
        return userDao.getUserByName(name);
    }

    public void refresh(String userName) {
        api.getUser(userName).enqueue(new Callback&lt;User&gt;() {
            @Override
            public void onResponse(Call&lt;User&gt; call, Response&lt;User&gt; response) {
                if (response.body() != null) {
                    insertUser(response.body());
                }
            }

            @Override
            public void onFailure(Call&lt;User&gt; call, Throwable t) {

            }
        });
    }

    private void insertUser(final User user) {
        AsyncTask.execute(new Runnable() {
            @Override
            public void run() {
                userDao.insertUser(user);
            }
        });
    }
}
</code></pre>
<h2 id="46-viewmodel-层">4.6 ViewModel 层</h2>
<p>在 ViewModel 的构造器中，实例化 Repository 对象，并将数据库对象和 Retrofit 对象以构造参数的形式传入 Repository 中。同样也是利用 LiveData 将 User 数据传递到上一层，即 View。</p>
<pre><code class="language-java">public class UserViewModel extends AndroidViewModel {
    private LiveData&lt;User&gt; user;
    private UserRepository userRepository;

    private String userName = &quot;yancechen&quot;;

    public UserViewModel(@NonNull Application application) {
        super(application);
        UserDatabase userDatabase = MyApplication.getUserDatabase();
        UserDao userDao = userDatabase.userDao();

        userRepository = new UserRepository(userDao, MyApplication.getApi());
        user = userRepository.getUser(userName);
    }

    public LiveData&lt;User&gt; getUser() {
        return user;
    }

    public void refresh() {
        userRepository.refresh(userName);
    }
}
</code></pre>
<h2 id="47-view-层">4.7 View 层</h2>
<p>在 Activity 中，我们使用了 DataBinding 组件和下拉刷新组件。当 User 数据发生变化时，自动通过回调方法得到通知，在接收到通知后，将数据交给布局文件进行处理。</p>
<p>我们首先来看看 Activity 的布局文件：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;

    &lt;data&gt;
        &lt;variable
            name=&quot;user&quot;
            type=&quot;com.yance.model.User&quot; /&gt;
    &lt;/data&gt;

    &lt;androidx.swiperefreshlayout.widget.SwipeRefreshLayout
        android:id=&quot;@+id/swipeRefresh&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;&gt;

        &lt;androidx.constraintlayout.widget.ConstraintLayout
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;match_parent&quot;
            android:background=&quot;@android:color/darker_gray&quot;
            tools:context=&quot;.MainActivity&quot;&gt;

            &lt;ImageView
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;230dp&quot;
                android:scaleType=&quot;fitXY&quot;
                android:src=&quot;@drawable/top_bg&quot;
                app:layout_constraintLeft_toLeftOf=&quot;parent&quot;
                app:layout_constraintRight_toRightOf=&quot;parent&quot;
                app:layout_constraintTop_toTopOf=&quot;parent&quot;/&gt;

            &lt;View
                android:id=&quot;@+id/white_bg_view&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;match_parent&quot;
                android:layout_marginLeft=&quot;20dp&quot;
                android:layout_marginTop=&quot;160dp&quot;
                android:layout_marginRight=&quot;20dp&quot;
                android:background=&quot;@android:color/white&quot;
                app:layout_constraintBottom_toBottomOf=&quot;parent&quot;
                app:layout_constraintLeft_toLeftOf=&quot;parent&quot;
                app:layout_constraintRight_toRightOf=&quot;parent&quot;
                app:layout_constraintTop_toTopOf=&quot;parent&quot;/&gt;

            &lt;ImageView
                android:id=&quot;@+id/avatar_civ&quot;
                android:layout_width=&quot;96dp&quot;
                android:layout_height=&quot;96dp&quot;
                app:layout_constraintLeft_toLeftOf=&quot;parent&quot;
                app:layout_constraintRight_toRightOf=&quot;parent&quot;
                app:layout_constraintTop_toTopOf=&quot;parent&quot;
                android:layout_marginTop=&quot;118dp&quot;
                app:imageUrl=&quot;@{user.avatar}&quot;
                app:placeHolder=&quot;@{@drawable/avatar_default}&quot;
                app:error=&quot;@{@drawable/avatar_default}&quot;/&gt;

            &lt;TextView
                android:id=&quot;@+id/name_tv&quot;
                android:layout_width=&quot;wrap_content&quot;
                android:layout_height=&quot;wrap_content&quot;
                android:layout_marginTop=&quot;20dp&quot;
                android:text=&quot;@{user.name}&quot;
                android:textColor=&quot;#333333&quot;
                android:textSize=&quot;22sp&quot;
                android:textStyle=&quot;bold&quot;
                app:layout_constraintLeft_toLeftOf=&quot;parent&quot;
                app:layout_constraintRight_toRightOf=&quot;parent&quot;
                app:layout_constraintTop_toBottomOf=&quot;@+id/avatar_civ&quot;/&gt;

            &lt;TextView
                android:id=&quot;@+id/bio_tv&quot;
                android:layout_width=&quot;wrap_content&quot;
                android:layout_height=&quot;wrap_content&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:text=&quot;@{user.bio}&quot;
                android:textColor=&quot;#999999&quot;
                android:textSize=&quot;16sp&quot;
                app:layout_constraintLeft_toLeftOf=&quot;parent&quot;
                app:layout_constraintRight_toRightOf=&quot;parent&quot;
                app:layout_constraintTop_toBottomOf=&quot;@+id/name_tv&quot;/&gt;

            &lt;TextView
                android:id=&quot;@+id/location_tv&quot;
                android:layout_width=&quot;wrap_content&quot;
                android:layout_height=&quot;wrap_content&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:text=&quot;@{@string/location(user.location)}&quot;
                android:textColor=&quot;#999999&quot;
                android:textSize=&quot;16sp&quot;
                app:layout_constraintLeft_toLeftOf=&quot;parent&quot;
                app:layout_constraintRight_toRightOf=&quot;parent&quot;
                app:layout_constraintTop_toBottomOf=&quot;@+id/bio_tv&quot;/&gt;

            &lt;TextView
                android:id=&quot;@+id/followers_tv&quot;
                android:layout_width=&quot;wrap_content&quot;
                android:layout_height=&quot;wrap_content&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:text=&quot;@{@string/followers(Integer.toString(user.followers))}&quot;
                android:textColor=&quot;#999999&quot;
                android:textSize=&quot;16sp&quot;
                app:layout_constraintLeft_toLeftOf=&quot;parent&quot;
                app:layout_constraintRight_toLeftOf=&quot;@+id/following_tv&quot;
                app:layout_constraintTop_toBottomOf=&quot;@+id/location_tv&quot;/&gt;

            &lt;TextView
                android:id=&quot;@+id/following_tv&quot;
                android:layout_width=&quot;wrap_content&quot;
                android:layout_height=&quot;wrap_content&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:text=&quot;@{@string/following(Integer.toString(user.following))}&quot;
                android:textColor=&quot;#999999&quot;
                android:textSize=&quot;16sp&quot;
                app:layout_constraintLeft_toRightOf=&quot;@+id/followers_tv&quot;
                app:layout_constraintRight_toRightOf=&quot;parent&quot;
                app:layout_constraintTop_toBottomOf=&quot;@+id/location_tv&quot;/&gt;

            &lt;TextView
                android:id=&quot;@+id/html_url_tv&quot;
                android:layout_width=&quot;wrap_content&quot;
                android:layout_height=&quot;wrap_content&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:text=&quot;@{user.html_url}&quot;
                android:textColor=&quot;#999999&quot;
                android:textSize=&quot;16sp&quot;
                app:layout_constraintLeft_toLeftOf=&quot;parent&quot;
                app:layout_constraintRight_toRightOf=&quot;parent&quot;
                app:layout_constraintTop_toBottomOf=&quot;@+id/following_tv&quot;/&gt;

            &lt;TextView
                android:id=&quot;@+id/blog_tv&quot;
                android:layout_width=&quot;wrap_content&quot;
                android:layout_height=&quot;wrap_content&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:text=&quot;@{user.blog}&quot;
                android:textColor=&quot;#999999&quot;
                android:textSize=&quot;16sp&quot;
                app:layout_constraintLeft_toLeftOf=&quot;parent&quot;
                app:layout_constraintRight_toRightOf=&quot;parent&quot;
                app:layout_constraintTop_toBottomOf=&quot;@+id/html_url_tv&quot;/&gt;

        &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;
    &lt;/androidx.swiperefreshlayout.widget.SwipeRefreshLayout&gt;
&lt;/layout&gt;
</code></pre>
<p>使用 DataBinding 的一个方便的地方是，在布局文件里，View 可以直接绑定它需要的数据。</p>
<figure data-type="image" tabindex="3"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8b3971885d3453da88e70ce0fe3f525~tplv-k3u1fbpfcp-watermark.image" alt="" loading="lazy"></figure>
<p>使用一个 @ 符号再加上 {} ，中间写上需要的对应字段即可完成 View 与数据的绑定，如 <code>@{user.blog}</code>。</p>
<p>对于 TextView 来说绑定数据很容易，如果是 ImageView 想加载一张网络图片呢？</p>
<p>方法是使用 <strong>BindingAdapter</strong>。</p>
<p>BindingAdapter 用来设置布局中 View 的自定义属性，当使用该属性时，可以自定义其行为。</p>
<pre><code class="language-java">public class ImageViewAttrAdapter {
    @BindingAdapter(&quot;android:src&quot;)
    public static void setSrc(ImageView view, Bitmap bitmap) {
        view.setImageBitmap(bitmap);
    }

    @BindingAdapter(&quot;android:src&quot;)
    public static void setSrc(ImageView view, int resId) {
        view.setImageResource(resId);
    }

    /**
     * 这里loadImage()绑定了多个属性，&quot;app:imageUrl&quot;、“app:placeHolder”、&quot;app:error&quot;属性。
     * 分别表示要加载的图片路径，占位图片，和加载出错时加载的图片。
     *
     * @param imageView
     * @param url
     * @param holderDrawable
     * @param errorDrawable
     */
    @BindingAdapter({&quot;app:imageUrl&quot;, &quot;app:placeHolder&quot;, &quot;app:error&quot;})
    public static void loadImage(ImageView imageView, String url, Drawable holderDrawable, Drawable errorDrawable) {
        Glide.with(imageView.getContext())
                .load(url)
                .transform(new CircleCrop())
                .placeholder(holderDrawable)
                .error(errorDrawable)
                .into(imageView);
    }
}
</code></pre>
<p>当一个方法加上 @BindingAdapter 注解后，就定义了一个 BindingAdapter，注意方法的第一个参数是需要绑定到的 View，第二个参数是绑定的属性值。</p>
<p>当定义完成后，此时我们就可以在布局的 View 中使用该属性，举例如下：</p>
<pre><code class="language-xml">&lt;ImageView
    android:id=&quot;@+id/avatar_civ&quot;
    android:layout_width=&quot;96dp&quot;
    android:layout_height=&quot;96dp&quot;
    app:imageUrl=&quot;@{user.avatar}&quot;
    app:placeHolder=&quot;@{@drawable/avatar_default}&quot;
    app:error=&quot;@{@drawable/avatar_default}&quot;/&gt;
</code></pre>
<p>下面来看看 Activity 的代码：</p>
<pre><code class="language-java">public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        final ActivityMainBinding activityMainBinding = DataBindingUtil.setContentView(this, R.layout.activity_main);

        final UserViewModel userViewModel = new ViewModelProvider(this, ViewModelProvider.AndroidViewModelFactory.getInstance(MyApplication.getInstance())).get(UserViewModel.class);

        userViewModel.getUser().observe(this, new Observer&lt;User&gt;() {
            @Override
            public void onChanged(User user) {
                if (user != null) {
                    //更新布局文件中的 User 对象，UI 也会自动更新
                    activityMainBinding.setUser(user);
                }
            }
        });

        final SwipeRefreshLayout swipeRefresh = activityMainBinding.swipeRefresh;
        swipeRefresh.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() {
            @Override
            public void onRefresh() {
                userViewModel.refresh();
                swipeRefresh.setRefreshing(false);
            }
        });
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Jetpack 之 LifeCycle 组件原理解析]]></title>
        <id>https://yancechen.github.io/post/jetpack-zhi-lifecycle-zu-jian-yuan-li-jie-xi/</id>
        <link href="https://yancechen.github.io/post/jetpack-zhi-lifecycle-zu-jian-yuan-li-jie-xi/">
        </link>
        <updated>2020-09-28T07:40:17.000Z</updated>
        <content type="html"><![CDATA[<p>对于 LifeCycle 组件还不了解的同学，可以先阅读这篇文章：</p>
<p><a href="https://yancechen.github.io/post/jetpack-zhi-lifecycle-zu-jian-shi-yong-xiang-jie/">Jetpack 之 LifeCycle 组件使用详解</a></p>
<h1 id="学习问题">学习问题</h1>
<ol>
<li>
<p>LifeCycle 是如何监听到 Activity/Fragment 生命周期变化的？</p>
</li>
<li>
<p>LifeCycle 如何将生命周期变化的事件分发给观察者的？</p>
</li>
</ol>
<h1 id="本文目录">本文目录</h1>
<figure data-type="image" tabindex="1"><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a41387880625432da98b49f670c42977~tplv-k3u1fbpfcp-zoom-1.image" alt="" loading="lazy"></figure>
<h1 id="一-四个重要的类">一、四个重要的类</h1>
<h2 id="一lifecycle">（一）Lifecycle</h2>
<p>Lifecycle 是一个抽象类。它内部定义了两个枚举：<code>Event</code> 需要分发的事件的类型，<code>State</code> 宿主的状态。</p>
<h3 id="1event">1.Event</h3>
<pre><code class="language-java">public enum Event {
    //对应于宿主（实现了LifecycleOwner的类）的 onCreate 方法
    ON_CREATE,
        
    //对应于宿主（实现了LifecycleOwner的类）的 onStart 方法
    ON_START,
        
    //对应于宿主（实现了LifecycleOwner的类）的 onResume 方法
    ON_RESUME,
        
    //对应于宿主（实现了LifecycleOwner的类）的 onPause 方法
    ON_PAUSE,
        
    //对应于宿主（实现了LifecycleOwner的类）的 onStop 方法
    ON_STOP,
        
    //对应于宿主（实现了LifecycleOwner的类）的 onDestroy 方法
    ON_DESTROY,
        
    //可以匹配宿主的所有生命周期事件
    ON_ANY
}
</code></pre>
<p>各个生命周期事件分发的时机：</p>
<p>ON_CREATE、ON_START 和 ON_RESUME：这三个生命周期事件是在宿主相应的生命周期方法 <strong>执行完成之后</strong> 被分发。</p>
<p>ON_PAUSE、ON_STOP 和 ON_DESTROY：这三个生命周期事件是在宿主相应的生命周期方法 <strong>被调用之前</strong> 分发。</p>
<h3 id="2state">2.State</h3>
<pre><code class="language-java">public enum State {

    //已销毁状态。以 Activity 为例，在回调 Activity 的 onDestroy 方法之前，宿主会达到此状态。
    DESTROYED,

    //已初始化状态。在回调 onCreate 方法之前的一种状态。
    INITIALIZED,

    //已创建状态。两种情况下回处于这种状态：
    //1.宿主的 onCreate 方法执行之后
    //2.宿主的 onStop 方法调用之前
    CREATED,

    //可见状态。两种情况下回处于这种状态：
    //1.宿主的 onStart 方法执行之后
    //2.宿主的 onPause 方法调用之前
    STARTED,

    //聚焦（可交互状态）。宿主执行了 onResume 方法后处于该状态。
    RESUMED;

    public boolean isAtLeast(@NonNull State state) {
        return compareTo(state) &gt;= 0;
    }
}
</code></pre>
<h3 id="3event-和-state-的对应关系">3.Event 和 State 的对应关系</h3>
<figure data-type="image" tabindex="2"><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3197f4aeafd454b8468ab2a19bf1ddf~tplv-k3u1fbpfcp-zoom-1.image" alt="" loading="lazy"></figure>
<h2 id="二lifecycleregistry">（二）LifecycleRegistry</h2>
<p>它是 Lifecycle 的唯一实现类。主要用来注册观察者（LifecycleObserver），以及分发宿主状态给它们（可以处理多个观察者）。</p>
<h2 id="三lifecycleowner">（三）LifecycleOwner</h2>
<p>用来声明它是一个能够提供生命周期事件的宿主，Activity/Fragment 都实现了该接口。内部只有一个 getLifecycle 方法。</p>
<pre><code class="language-java">public interface LifecycleOwner {
    @NonNull
    Lifecycle getLifecycle();
}
</code></pre>
<h2 id="四lifecycleobserver">（四）LifecycleObserver</h2>
<p>用来定义观察者。</p>
<h1 id="二-四个类之间的关系">二、四个类之间的关系</h1>
<figure data-type="image" tabindex="3"><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a5a6363bad64e6a8e647018e2fc438d~tplv-k3u1fbpfcp-zoom-1.image" alt="LifeCycle 类关系图" loading="lazy"></figure>
<p>说明：</p>
<ol>
<li>Activity/Fragment 都默认实现了 LifecycleOwner 接口；</li>
<li>LifecycleRegistry 是 Lifecycle 唯一的实现类；</li>
<li>实现观察者（Observer）有三种方式：
<ul>
<li>LifecycleObserver 配合 @OnLifecycleEvent 注解</li>
<li>DefaultLifecycleObserver 拥有宿主所有生命周期事件</li>
<li>LifecycleEventObserver 将宿主生命周期事件封装成 Lifecycle.Event</li>
</ul>
</li>
<li>在 Activity/Fragment 中通过 <code>getLifecycle()</code> 方法获取到一个 LifecycleRegistry 对象；</li>
<li>通过调用 LifecycleRegistry 对象的 <code>addObserver()</code> 添加一个观察者（该观察者通过三种方式实现都可以）。</li>
</ol>
<h1 id="三-fragment-如何实现-lifycycle">三、Fragment 如何实现 LifyCycle</h1>
<p>在 Fragment 各个生命周期方法内部会利用 LifecycleRegistry 进行相应的事件分发。</p>
<pre><code class="language-java">public class Fragment implements LifecycleOwner {

    LifecycleRegistry mLifecycleRegistry;

    void performCreate(Bundle savedInstanceState) {
        onCreate(savedInstanceState);
        //ON_CREATE 事件在执行了 onCreate 方法之后分发 
        mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);
    }

    void performStart() {
        onStart();
        //ON_START 事件在执行了 onStart 方法之后分发
        mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START);
    }

    void performResume() {
        onResume();
        //ON_RESUME 事件在执行了 onResume 方法之后分发
        mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_RESUME);
    }

    void performPause() {
        //ON_PAUSE 事件在执行 onPause 方法执行之前分发
        mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE);
        onPause();
    }

    void performStop() {
        //ON_STOP 事件在执行 onStop 方法执行之前分发
        mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_STOP);
        onStop();
    }

    void performDestroy() {
        //ON_DESTROY 事件在执行 onDestroy 方法执行之前分发
        mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_DESTROY);
        onDestroy();
    }
}
</code></pre>
<h1 id="四-activity-如何实现-lifycycle">四、Activity 如何实现 LifyCycle</h1>
<p>Activity 实现 Lifecycle 需要借助于 ReportFragment 往 Activity 上添加一个 fragment。ReportFragment 没有任何的页面，它只负责在生命周期变化时利用 LifecycleRegistry 进行相应事件的分发。</p>
<p>之所以需要借助 ReportFragment ，目的是为了兼顾不是继承自 AppCompactActivity 的场景， 同时也支持我们自定义 LifecycleOwner 的场景。</p>
<h2 id="一componentactivity-的源码分析">（一）ComponentActivity 的源码分析</h2>
<p>以下是 ComponentActivity 的源码，在 onCreate 方法中往 Activity 里面添加了一个 fragment。</p>
<pre><code class="language-java">public class ComponentActivity extends Activity implements LifecycleOwner {
  
    private LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this);

    @SuppressLint(&quot;RestrictedApi&quot;)
    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        //添加一个 fragment
        ReportFragment.injectIfNeededIn(this);
    }
}
</code></pre>
<p>补充一下 Activity 的继承关系：</p>
<figure data-type="image" tabindex="4"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d8a4d3ed71c412e9e595ed256fbb96a~tplv-k3u1fbpfcp-zoom-1.image" alt="" loading="lazy"></figure>
<h2 id="二reportfragment-的源码分析">（二）ReportFragment 的源码分析</h2>
<p>下面来看看 ReportFragment 的源码。在 ReportFragment 中最主要的一个方法是 injectIfNeededIn。</p>
<pre><code class="language-java">public class ReportFragment extends Fragment {
    
    ...

    public static void injectIfNeededIn(Activity activity) {
        //1.如果 API &gt;= 29 ,注册 ActivityLifecycleCallbacks
        if (Build.VERSION.SDK_INT &gt;= 29) {
            activity.registerActivityLifecycleCallbacks(
                    new LifecycleCallbacks());
        }

        //2.添加一个 ReportFragment 到 Activity 中
        android.app.FragmentManager manager = activity.getFragmentManager();
        if (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == null) {
            manager.beginTransaction().add(new ReportFragment(), REPORT_FRAGMENT_TAG).commit();
            manager.executePendingTransactions();
        }
    }

    ...
</code></pre>
<p>injectIfNeededIn 方法会做两件事情：</p>
<h3 id="1判断当前的-api-level根据-api-level-选择监听-activity-生命周期的时机和方式">1.判断当前的 API Level，根据 API Level 选择监听 Activity 生命周期的时机和方式</h3>
<h4 id="1api-level-29">（1）API Level &gt;= 29</h4>
<p>如果大于等于 29 的话，会注册一个 ActivityLifecycleCallbacks，</p>
<pre><code class="language-java">if (Build.VERSION.SDK_INT &gt;= 29) {
    activity.registerActivityLifecycleCallbacks(new LifecycleCallbacks());
}
</code></pre>
<p>ActivityLifecycleCallbacks 是 Application 的一个内部接口。</p>
<pre><code class="language-java">public interface ActivityLifecycleCallbacks {
        void onActivityCreated(@NonNull Activity activity, @Nullable Bundle savedInstanceState);
        void onActivityStarted(@NonNull Activity activity);
        void onActivityResumed(@NonNull Activity activity);
        void onActivityPaused(@NonNull Activity activity);
        void onActivityStopped(@NonNull Activity activity);
        void onActivityDestroyed(@NonNull Activity activity);
    }
</code></pre>
<p>以 Activity 的 onResume() 生命周期为例，如果我们注册了 ActivityLifecycleCallbacks，Android 系统会先回调 ActivityLifecycleCallbacks 的 onActivityResumed 方法，然后才执行 Android 本身的 onResume() 方法。</p>
<p>利用这个特点，我们可以注册一个自定义的 ActivityLifecycleCallbacks，在自定义的 ActivityLifecycleCallbacks 添加分发生命周期事件的逻辑来通知观察者：</p>
<pre><code class="language-java">public class ReportFragment extends Fragment {

    public static void injectIfNeededIn(Activity activity) {
        if (Build.VERSION.SDK_INT &gt;= 29) {
            activity.registerActivityLifecycleCallbacks(
                    new LifecycleCallbacks());
        }
        
        android.app.FragmentManager manager = activity.getFragmentManager();
        if (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == null) {
            manager.beginTransaction().add(new ReportFragment(), REPORT_FRAGMENT_TAG).commit();
            manager.executePendingTransactions();
        }
    }

    @SuppressWarnings(&quot;deprecation&quot;)
    static void dispatch(@NonNull Activity activity, @NonNull Lifecycle.Event event) {
        ...

        if (activity instanceof LifecycleOwner) {
            Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();
            if (lifecycle instanceof LifecycleRegistry) {
                //最终还是通过 LifecycleRegistry 来处理事件的分发
                ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);
            }
        }
    }

    //自定义 ActivityLifecycleCallbacks 来处理生命周期事件的分发，通知观察者
    static class LifecycleCallbacks implements Application.ActivityLifecycleCallbacks {
        
        ...

        @Override
        public void onActivityPostCreated(@NonNull Activity activity,
                @Nullable Bundle savedInstanceState) {
            //分发 ON_CREATE 事件
            dispatch(activity, Lifecycle.Event.ON_CREATE);
        }

        @Override
        public void onActivityPostStarted(@NonNull Activity activity) {
            //分发 ON_START 事件
            dispatch(activity, Lifecycle.Event.ON_START);
        }

        @Override
        public void onActivityPostResumed(@NonNull Activity activity) {
            //分发 ON_RESUME 事件
            dispatch(activity, Lifecycle.Event.ON_RESUME);
        }

        @Override
        public void onActivityPrePaused(@NonNull Activity activity) {
            //分发 ON_PAUSE 事件
            dispatch(activity, Lifecycle.Event.ON_PAUSE);
        }

        @Override
        public void onActivityPreStopped(@NonNull Activity activity) {
            //分发 ON_STOP 事件
            dispatch(activity, Lifecycle.Event.ON_STOP);
        }

        @Override
        public void onActivityPreDestroyed(@NonNull Activity activity) {
            //分发 ON_DESTROY 事件
            dispatch(activity, Lifecycle.Event.ON_DESTROY);
        }

        ...

    }
}
</code></pre>
<h4 id="2api-level-29">（2）API Level &lt; 29</h4>
<p>对于 API 小于 29 的情况，它的实现方式和 Fragment 的实现是一样的，在各个生命周期方法内利用 LifecycleRegistry 分发相应的 Lifecycle.Event 事件给每个观察者：</p>
<pre><code class="language-java">public class ReportFragment extends Fragment {

    public static void injectIfNeededIn(Activity activity) {
        if (Build.VERSION.SDK_INT &gt;= 29) {
            activity.registerActivityLifecycleCallbacks(
                    new LifecycleCallbacks());
        }
        
        android.app.FragmentManager manager = activity.getFragmentManager();
        if (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == null) {
            manager.beginTransaction().add(new ReportFragment(), REPORT_FRAGMENT_TAG).commit();
            manager.executePendingTransactions();
        }
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);
        dispatch(Lifecycle.Event.ON_CREATE);
    }

    @Override
    public void onStart() {
        super.onStart();
        dispatch(Lifecycle.Event.ON_START);
    }

    @Override
    public void onResume() {
        super.onResume();
        dispatch(Lifecycle.Event.ON_RESUME);
    }

    @Override
    public void onPause() {
        super.onPause();
        dispatch(Lifecycle.Event.ON_PAUSE);
    }

    @Override
    public void onStop() {
        super.onStop();
        dispatch(Lifecycle.Event.ON_STOP);
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        dispatch(Lifecycle.Event.ON_DESTROY);
    }

    private void dispatch(@NonNull Lifecycle.Event event) {
        //在此处判断一下 API ，避免重复分发事件
        if (Build.VERSION.SDK_INT &lt; 29) {
            dispatch(getActivity(), event);
        }
    }
}
</code></pre>
<h3 id="2在-injectifneededin-中会创建一个-reportfragment-添加到-activity-中">2.在 injectIfNeededIn 中会创建一个 ReportFragment 添加到 Activity 中</h3>
<pre><code class="language-java">public class ReportFragment extends Fragment {
    
    public static void injectIfNeededIn(Activity activity) {

        ...

        //往 Activity 中添加一个 ReportFragment
        android.app.FragmentManager manager = activity.getFragmentManager();
        if (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == null) {
            manager.beginTransaction().add(new ReportFragment(), REPORT_FRAGMENT_TAG).commit();
            manager.executePendingTransactions();
        }
    }
}
</code></pre>
<h1 id="五-lifecycleregistry-源码分析">五、LifecycleRegistry 源码分析</h1>
<p>从前文的分析中，我们知道了 Activity/Fragment 是如何去实现 LifeCycle 的，对于生命周期事件的分发，它们最终都是交给了 LifecycleRegistry 去处理，因此，我们有比较去了解一下 LifecycleRegistry 内部的工作机制。</p>
<h2 id="一addobserver-源码分析">（一）addObserver() 源码分析</h2>
<p>LifeCycle 是通过观察者模式去实现的，添加一个观察者的方式是调用 addObserver() 方法：</p>
<pre><code class="language-java">getLifecycle().addObserver(observer);
</code></pre>
<p>先来看一下完整的 addObserver() 方法：</p>
<pre><code class="language-java">public void addObserver(@NonNull LifecycleObserver observer) {
        State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;
        ObserverWithState statefulObserver = new ObserverWithState(observer, initialState);
        ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);

        if (previous != null) {
            return;
        }
        LifecycleOwner lifecycleOwner = mLifecycleOwner.get();
        if (lifecycleOwner == null) {
            // it is null we should be destroyed. Fallback quickly
            return;
        }

        boolean isReentrance = mAddingObserverCounter != 0 || mHandlingEvent;
        State targetState = calculateTargetState(observer);
        mAddingObserverCounter++;
        while ((statefulObserver.mState.compareTo(targetState) &lt; 0
                &amp;&amp; mObserverMap.contains(observer))) {
            pushParentState(statefulObserver.mState);
            statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState));
            popParentState();
            // mState / subling may have been changed recalculate
            targetState = calculateTargetState(observer);
        }

        if (!isReentrance) {
            // we do sync only on the top level.
            sync();
        }
        mAddingObserverCounter--;
    }
</code></pre>
<p>下面，我们逐行代码来分析：</p>
<h3 id="1首先确定新添加的-observer-的初始化状态">1.首先确定新添加的 Observer 的初始化状态</h3>
<pre><code class="language-java">State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;
</code></pre>
<p>只要当前宿主的状态不是 <code>DESTROYED</code>，那么它的初始状态都是 <code>INITIALIZED</code>。</p>
<h3 id="2将-observer-包装成-observerwithstate">2.将 Observer 包装成 ObserverWithState</h3>
<pre><code class="language-java">ObserverWithState statefulObserver = new ObserverWithState(observer, initialState);
</code></pre>
<p>ObserverWithState 表示带有状态的 Observer，这个类后文会详细分析。</p>
<h3 id="3将-observer-添加到集合中">3.将 Observer 添加到集合中</h3>
<pre><code class="language-java">ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);

if (previous != null) {
    return;
}
</code></pre>
<p>通过 putIfAbsent() 方法将 ObserverWithState 添加到集合中，如果之前已经添加过了，putIfAbsent() 方法会直接返回之前添加过的 ObserverWithState，此时，程序会直接 return。</p>
<h3 id="4利用一个-while-循环将观察者和宿主的状态进行对齐">4.利用一个 while 循环将观察者和宿主的状态进行对齐</h3>
<pre><code class="language-java">//首先计算出观察者应该达到的状态
State targetState = calculateTargetState(observer);
//通过 compareTo 方法，将观察者的状态和宿主当前状态做比较，如果小于0，说明两者状态还没有对齐
while ((statefulObserver.mState.compareTo(targetState) &lt; 0
        &amp;&amp; mObserverMap.contains(observer))) {
    pushParentState(statefulObserver.mState);
    //执行一次事件分发
    statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState));
    popParentState();
    //计算观察者下一个应该到达的状态，在下次循环中观察者状态还会与之对比，直到状态对齐，退出循环
    targetState = calculateTargetState(observer);
}
</code></pre>
<p>根据 while 循环的逻辑，我们可以得出一个结论：</p>
<p>在 Activity/Fragment 的任意生命周期方法内注册观察者都能接收到完整的生命周期事件。</p>
<p>比如，我们在 onResume() 方法内注册观察者：</p>
<ul>
<li>while 第一次循环：分发 on_Create 事件，观察者状态 INITIALIZED -&gt; CREATED</li>
<li>while 第二次循环：分发 on_Start 事件，观察者状态 CREATED -&gt; STARTED</li>
<li>while 第三次循环：分发 on_Resume 事件，观察者状态 STARTED -&gt; RESUMED</li>
</ul>
<p>不过，建议最好是在 onCreate 方法中进行注册。</p>
<p>关于使用 compareTo 比较两个枚举值，请参考文章：</p>
<p><a href="https://www.w3cschool.cn/java/java-enum-compare.html">Java 枚举比较</a></p>
<h2 id="二handlelifecycleevent-源码分析">（二）handleLifecycleEvent() 源码分析</h2>
<p>handleLifecycleEvent() 方法主要是负责宿主生命周期变化后相应的事件分发。</p>
<pre><code class="language-java">public void handleLifecycleEvent(@NonNull Lifecycle.Event event) {
        State next = getStateAfter(event);
        moveToState(next);
    }
</code></pre>
<h3 id="1首先根据需要分发的事件获取宿主当前处于什么状态">1.首先根据需要分发的事件，获取宿主当前处于什么状态</h3>
<p>假设分发的是 <code>ON_START</code> 事件，那么根据 getStateAfter() 方法我们可以知道，宿主当前是处于 <code>STARTED</code> 状态。</p>
<pre><code>static State getStateAfter(Event event) {
        switch (event) {
            case ON_CREATE:
            case ON_STOP:
                return CREATED;
            case ON_START:
            case ON_PAUSE:
                return STARTED;
            case ON_RESUME:
                return RESUMED;
            case ON_DESTROY:
                return DESTROYED;
            case ON_ANY:
                break;
        }
</code></pre>
<h3 id="2根据第一步获取的宿主状态设置当前的状态并通知观察者">2.根据第一步获取的宿主状态设置当前的状态并通知观察者</h3>
<pre><code class="language-java">private void moveToState(State next) {
        if (mState == next) {
            return;
        }
        //设置当前状态
        mState = next;

        ...

        //通知观察者
        sync();
    }
</code></pre>
<p>下面来看一下 sync 方法：</p>
<pre><code class="language-java">private void sync() {
        
    while (!isSynced()) {
    
        //如果宿主当前的状态 小于 mObserverMap 集合中最先添加的那个观察者的状态
        //则说明宿主可能发生了状态回退，比如当前是 RESUMED 状态，执行了onPause 则回退到STARTED 状态
        //此时调用 backwardPass 给集合中的每个一观察者分发一个 on_pause 事件，并同步它的状态。
        if (mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; 0) {
            backwardPass(lifecycleOwner);
        }

        //如果宿主当前状态 大于 mObserverMap 集合中最先添加的那个观察者的状态
        //则说明宿主可能发生了状态前进，比如当前是 STARTED 状态，执行了onResume 则前进到RESUMED 状态
        //此时调用 forwardPass 给集合中的每个一观察者分发一个 on_resume 事件，并同步它的状态。
        Entry&lt;LifecycleObserver, ObserverWithState&gt; newest = mObserverMap.newest();
        if (!mNewEventOccurred &amp;&amp; newest != null
                &amp;&amp; mState.compareTo(newest.getValue().mState) &gt; 0) {
            forwardPass(lifecycleOwner);
        }
    }
    mNewEventOccurred = false;
}
</code></pre>
<h2 id="三observerwithstate-源码分析">（三）ObserverWithState 源码分析</h2>
<p>ObserverWithState 是 LifecycleRegistry 中持有观察者及其状态的内部类。</p>
<pre><code class="language-java">static class ObserverWithState {
    State mState;
    LifecycleEventObserver mLifecycleObserver;

    //把传入的 LifecycleObserver 适配成 LifecycleEventObserver，目的是为了统一事件的分发形式。
    //在之前的文章里介绍过实现观察者有三种形式，每一种接收的事件类型都不一样，如果在分发的时候不统一事件分发的形式，将会变得很麻烦
    ObserverWithState(LifecycleObserver observer, State initialState) {
        mLifecycleObserver = Lifecycling.lifecycleEventObserver(observer);
        mState = initialState;
    }

    void dispatchEvent(LifecycleOwner owner, Event event) {
        State newState = getStateAfter(event);
        mState = min(mState, newState);
        //执行事件分发
        mLifecycleObserver.onStateChanged(owner, event);
        mState = newState;
    }
}
</code></pre>
<h1 id="六-参考资料">六、参考资料</h1>
<p><a href="https://developer.android.google.cn/jetpack">Google Jetpack 官方文档</a></p>
<p><a href="https://www.imooc.com/u/index/read">慕课专栏：跟架构师学Jetpack</a></p>
<p>《Android Jetpack 应用指南》叶坤</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Jetpack 之 LifeCycle 组件使用详解]]></title>
        <id>https://yancechen.github.io/post/jetpack-zhi-lifecycle-zu-jian-shi-yong-xiang-jie/</id>
        <link href="https://yancechen.github.io/post/jetpack-zhi-lifecycle-zu-jian-shi-yong-xiang-jie/">
        </link>
        <updated>2020-09-16T04:56:29.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-lifecycle-简介">一、LifeCycle 简介</h1>
<p>LifeCycle 是一个可以感知宿主生命周期变化的组件。常见的宿主包括 Activity/Fragment、Service 和 Application。LifeCycle 会持有宿主的生命周期状态的信息，当宿主生命周期发生变化时，会通知监听宿主的观察者。</p>
<p><strong>LifeCycle 的出现主要是为了解决：</strong> 系统组件的生命周期与普通组件之间的耦合性。</p>
<ul>
<li>系统组件指：Activity/Fragment、Service 和 Application。</li>
<li>普通组件指：将代码按照功能或者作用封装成的组件。</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd01ec517e5f4438bc618649435fe90f~tplv-k3u1fbpfcp-zoom-1.image" alt="LifeCycle 的原理" loading="lazy"></figure>
<p>哪些情况下，系统组件的生命周期会和普通组件的生命周期耦合在一起呢？</p>
<p><strong>举个栗子：</strong></p>
<p>在 58 部落业务中有视频播放的业务需求。我们需要在 Activity 中对视频播放组件进行初始化，在 onPause() 方法中停止视频的播放，在 onDestroy() 方法中对视频播放组件以及一些资源进行回收。这样的做法非常繁琐，会让页面与组件之间的耦合度变高。</p>
<p>对于这类问题，完全可以使用 LifeCycle 来解决。<strong>它不仅降低了模块之间的耦合度，还降低了内存泄露发生的可能性</strong>。</p>
<h1 id="二-lifecycle-的使用">二、LifeCycle 的使用</h1>
<p>Jetpack 为我们提供了两个接口：</p>
<p>被观察者：<code>LifecycleOwner</code></p>
<p>观察者：<code>LifecycleObserver</code></p>
<p>被监听的系统组件需要去实现 LifecycleOwner 接口，观察者需要实现 LifecycleObserver 接口。</p>
<h2 id="一使用场景1使用-lifecycle-解耦页面与组件">（一）使用场景1：使用 LifeCycle 解耦页面与组件</h2>
<h3 id="1解耦-activity">（1）解耦 Activity</h3>
<h4 id="第一步添加依赖">第一步：添加依赖</h4>
<pre><code class="language-groovy">implementation 'androidx.appcompat:appcompat:1.2.0'
</code></pre>
<p>在 AndroidX 里面 ComponentActivity 已经默认实现了 LifecycleOwner 接口。如果项目没有迁移到 AndroidX，还是用的 Support 库，新版本的 SDK 也通过 SupportActivity 实现了 LifecycleOwner 接口。</p>
<figure data-type="image" tabindex="2"><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6997c541919b4c61b6fd5c0a26c985e2~tplv-k3u1fbpfcp-zoom-1.image" alt="" loading="lazy"></figure>
<p>在 LifecycleOwner 接口中，只有一个 getLifecycle 方法。</p>
<h4 id="第二步实现观察者">第二步：实现观察者</h4>
<p>如果是想监听某个 Activity 的生命周期，需要我们做的就是自定义组件，实现 LifecycleObserver 接口即可，该接口没有接口方法，不需要任何具体的实现。</p>
<p>比如以刚刚的视频播放为例：</p>
<ol>
<li>创建一个 MyVideoPlayListener 类，实现 LifecycleObserver 接口，与视频播放相关的逻辑全在这个类里面完成。对于组件里面需要在 Activity 生命周期变化时得到通知的方法，用 @OnLifecycleEvent(Lifecycle.Event.ON_XXX) 注解进行标记，这样当 Activity 生命周期发生变化时，被标记过的方法便会被自动调用。</li>
</ol>
<pre><code class="language-java">public class MyVideoPlayListener implements LifecycleObserver {
    private static String TAG = &quot;MyVideoPlayListener&quot;;

    @OnLifecycleEvent(Lifecycle.Event.ON_CREATE)
    private void initVideo(){
        Log.d(TAG,&quot;initVideo&quot;);
    }

    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)
    private void startPlay(){
        Log.d(TAG,&quot;startPlay&quot;);
    }

    @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)
    private void pausePlay(){
        Log.d(TAG,&quot;pausePlay&quot;);
    }
}
</code></pre>
<p>2.在 MainActivity 中对 MyVideoPlayListener 进行引用即可。</p>
<pre><code class="language-java">public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        MyVideoPlayListener listener = new MyVideoPlayListener();
        getLifecycle().addObserver(listener);
    }
}
</code></pre>
<h3 id="2解耦-fragment">（2）解耦 Fragment</h3>
<p>在新版的 SDK 中，Fragment 同样也默认实现了 LifecycleOwner 接口，因此，以上的例子同样适合于 Fragment。</p>
<h2 id="二使用场景2使用-lifecycleservice-解耦-service-与组件">（二）使用场景2：使用 LifecycleService 解耦 Service 与组件</h2>
<h3 id="1lifecycleservice-基本介绍">（1）LifecycleService 基本介绍</h3>
<p>Android 中拥有生命周期的组件除了 Activity/Fragment ，还有一个非常重要的组件就是 Service。LifecycleService 就是用来监听和解耦 Service 组件的。</p>
<pre><code class="language-java">public class LifecycleService extends Service implements LifecycleOwner {

    private final ServiceLifecycleDispatcher mDispatcher = new ServiceLifecycleDispatcher(this);

    ......

    @Override
    @NonNull
    public Lifecycle getLifecycle() {
        return mDispatcher.getLifecycle();
    }
}
</code></pre>
<h3 id="2具体使用方法">（2）具体使用方法</h3>
<h4 id="第一步添加相关依赖">第一步：添加相关依赖</h4>
<pre><code class="language-groovy">implementation &quot;androidx.lifecycle:lifecycle-service:2.2.0&quot;
</code></pre>
<h4 id="第二步创建-myserviceobserver-类实现-lifecycleobserver-接口-使用-onlifecycleevent-标记希望在-server-生命周期发生变化时得到同步调用的方法">第二步：创建 MyServiceObserver 类，实现 LifecycleObserver 接口。使用 @OnLifecycleEvent 标记希望在 Server 生命周期发生变化时得到同步调用的方法。</h4>
<pre><code class="language-java">public class MyServiceObserver implements LifecycleObserver {
    private static String TAG = &quot;MyServiceObserver&quot;;

    @OnLifecycleEvent(Lifecycle.Event.ON_CREATE)
    private void initVideo(){
        Log.d(TAG,&quot;initVideo&quot;);
    }

    @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)
    private void pausePlay(){
        Log.d(TAG,&quot;stopPlay&quot;);
    }
}
</code></pre>
<h4 id="第三步创建一个-myservice-的类继承-lifecycleservice-由于-lifecycleservice-是-service-的直接子类所以使用起来与普通的-service-没有差别">第三步：创建一个 MyService 的类，继承 LifecycleService。由于 LifecycleService 是 Service 的直接子类，所以使用起来与普通的 Service 没有差别。</h4>
<pre><code class="language-java">public class MyService extends LifecycleService {
    private MyServiceObserver myServiceObserver;
    
    public MyService(){
        myServiceObserver = new MyServiceObserver();
        getLifecycle().addObserver(myServiceObserver);
    }
}
</code></pre>
<h2 id="三使用场景3使用-processlifecycleowner-监听应用程序的生命周期">（三）使用场景3：使用 ProcessLifecycleOwner 监听应用程序的生命周期</h2>
<p>具有生命周期的组件除了 Activity、Fragment 和 Service 外，还有 Application。ProcessLifecycleOwner 就是用来监听整个应用程序的生命周期情况。</p>
<p>具体使用方法：</p>
<h4 id="第一步添加依赖项">第一步：添加依赖项</h4>
<pre><code class="language-groovy">implementation &quot;androidx.lifecycle:lifecycle-process:2.2.0&quot;
</code></pre>
<h4 id="第二步定义一个-applicationobserver实现-lifecycleobserver-接口">第二步：定义一个 ApplicationObserver，实现 LifecycleObserver 接口。</h4>
<pre><code class="language-java">public class ApplicationObserver implements LifecycleObserver {
    private String TAG = this.getClass().getName();

    /**
     * 在应用程序的整个生命周期中只会被调用一次
     */
    @OnLifecycleEvent(Lifecycle.Event.ON_CREATE)
    public void onCreate() {
        Log.d(TAG,&quot;Lifecycle.Event.ON_CREATE&quot;);
    }

    @OnLifecycleEvent(Lifecycle.Event.ON_START)
    public void onStart() {
        Log.d(TAG,&quot;Lifecycle.Event.ON_START&quot;);
    }

    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)
    public void onResume() {
        Log.d(TAG,&quot;Lifecycle.Event.ON_RESUME&quot;);
    }

    @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)
    public void onPause() {
        Log.d(TAG,&quot;Lifecycle.Event.ON_PAUSE&quot;);
    }

    @OnLifecycleEvent(Lifecycle.Event.ON_STOP)
    public void onStop() {
        Log.d(TAG,&quot;Lifecycle.Event.ON_STOP&quot;);
    }

    /**
     * 永远不会被调用，系统不会分发调用 ON_DESTROY 事件
     */
    @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)
    public void onDestroy() {
        Log.d(TAG,&quot;Lifecycle.Event.ON_DESTROY&quot;);
    }
}
</code></pre>
<h4 id="第三步在-application-中关联-applicationobserver">第三步：在 Application 中关联 ApplicationObserver。</h4>
<pre><code class="language-java">public class App extends Application {
    @Override
    public void onCreate() {
        super.onCreate();
        ProcessLifecycleOwner.get().getLifecycle().addObserver(new ApplicationObserver());
    }
}
</code></pre>
<p><strong>注意事项：</strong></p>
<ol>
<li>ProcessLifecycleOwner 是针对整个应用程序的监听，与 Activity 的数量无关。</li>
<li>Lifecycle.Event.ON_CREATE 只会被调用一次，而 Lifecycle.Event.ON_DESTROY 永远不会被调用。</li>
<li>Lifecycle.Event.ON_PAUSE 和 Lifecycle.Event.ON_STOP 的调用会有一定的延后，因为系统需要为“屏幕旋转，由于配置发生变化而导致的 Activity 重新创建” 的情况预留一些时间。</li>
</ol>
<h1 id="三-lifecycle-的另外两种写法">三、LifeCycle 的另外两种写法</h1>
<p>LifeCycle 有三种实现方法：</p>
<ol>
<li>LifecycleObserver 配合 <code>@OnLifecycleEvent</code> 注解</li>
<li>DefaultLifecycleObserver 拥有宿主所有生命周期事件</li>
<li>LifecycleEventObserver 将宿主生命周期事件封装成 Lifecycle.Event</li>
</ol>
<p>在上一节使用介绍中，我们用的是第一种方式：LifecycleObserver 配合 <code>@OnLifecycleEvent</code> 注解。</p>
<p>这种方式使用比较简单，但是注意最好添加 lifecycle-compiler 这个注解处理器，否者在运行时会使用反射的形式回调到对应的方法上：</p>
<pre><code class="language-groovy">annotationProcessor &quot;androidx.lifecycle:lifecycle-compiler:2.2.0&quot;
</code></pre>
<p>加上这个注解处理器后，用 <code>@OnLifecycleEvent</code> 标记的方法就不能再声明成 <code>private</code> ，否者会报如下的错误：</p>
<pre><code class="language-java">method marked with OnLifecycleEvent annotation can not be private
</code></pre>
<p>下面介绍一下另外两种实现方式：</p>
<h2 id="一defaultlifecycleobserver-拥有宿主所有生命周期事件">（一）DefaultLifecycleObserver 拥有宿主所有生命周期事件</h2>
<p>使用 DefaultLifecycleObserver 需要用到 <code>Java8</code>，我们首先添加依赖：</p>
<pre><code>implementation &quot;androidx.lifecycle:lifecycle-common-java8:2.2.0&quot;
</code></pre>
<p>然后在模块级别的 build.gradle 中添加：</p>
<pre><code class="language-groovy">android {
  ...
  compileOptions {
    sourceCompatibility JavaVersion.VERSION_1_8
    targetCompatibility JavaVersion.VERSION_1_8
  }
}
</code></pre>
<p>使用 lifecycle-common-java8 依赖后，就可以将 lifecycle-compiler 依赖去掉。</p>
<p>DefaultLifecycleObserver 接口中有 6 个生命周期方法：</p>
<pre><code class="language-java">public interface DefaultLifecycleObserver extends FullLifecycleObserver {

    @Override
    default void onCreate(@NonNull LifecycleOwner owner) {
    }

    @Override
    default void onStart(@NonNull LifecycleOwner owner) {
    }

    @Override
    default void onResume(@NonNull LifecycleOwner owner) {
    }

    @Override
    default void onPause(@NonNull LifecycleOwner owner) {
    }

    @Override
    default void onStop(@NonNull LifecycleOwner owner) {
    }

    @Override
    default void onDestroy(@NonNull LifecycleOwner owner) {
    }
}
</code></pre>
<p>该接口继承自 FullLifecycleObserver ，由于权限问题，我们不能直接使用 FullLifecycleObserver 来拥有宿主的所有生命周期事件。</p>
<p>所以，我们需要通过实现 DefaultLifecycleObserver 接口，然后重写自己业务需要监听的生命周期方法。</p>
<h2 id="二lifecycleeventobserver-宿主生命周期事件封装成-lifecycleevent">（二）LifecycleEventObserver 宿主生命周期事件封装成 Lifecycle.Event</h2>
<pre><code class="language-java">//通过实现 LifecycleEventObserver 接口，重写 onStateChanged 方法，在该方法内部
//通过判断 Lifecycle.Event 来实现具体的业务逻辑
public class MyVideoPlayObserver implements LifecycleEventObserver {
    private static String TAG = &quot;MyVideoPlayObserver&quot;;

    @Override
    public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event) {
        switch (event){
            case ON_CREATE:
                Log.d(TAG,&quot;initVideo&quot;);
                break;
            case ON_START:
                Log.d(TAG,&quot;startPlay&quot;);
                break;
            case ON_RESUME:
                Log.d(TAG,&quot;resumePlay&quot;);
                break;
            default:
                 break;
        }
    }
}
</code></pre>
<p>对于这三种实现方式如何选择呢？</p>
<p><strong>建议使用 DefaultLifecycleObserver 和 LifecycleEventObserver 的方式。</strong></p>
<ol>
<li>Java8 使用 DefaultLifecycleObserver 来实现 Lifecycle，Java7 使用注解的方式。如果一旦 Java8 成为 Android 的主流后，注解的方式会被弃用。</li>
<li>如果一个类同时实现了 DefaultLifecycleObserver 接口和 LifecycleEventObserver 接口，那么 DefaultLifecycleObserver 中的方法会先触发，然后才执行 LifecycleEventObserver 的  onStateChanged 方法。</li>
<li>如果一个类实现了 DefaultLifecycleObserver 接口，同时使用了 <code>@OnLifecycleEvent</code> 注解，那么注解的方式会被自动忽略掉。</li>
</ol>
<h1 id="四-总结">四、总结</h1>
<p><strong>LifeCycle 组件存在的主要意义是帮助我们解耦，让自己定义的组件也能够感受到生命周期的变化。</strong></p>
<h1 id="五-补充">五、补充</h1>
<p>截止本文发布时，lifecycle_version 最新版本是 <code>2.2.0</code>，如需获取最新版本请查看官网：</p>
<p>https://developer.android.google.cn/jetpack/androidx/releases/lifecycle</p>
<p>注：<code>lifecycle-extensions</code> 中的 API 已弃用，需要使用到 Lifecycle 下的某个工具时，添加对应的依赖即可：</p>
<pre><code class="language-groovy">    dependencies {
        def lifecycle_version = &quot;2.2.0&quot;
        def arch_version = &quot;2.1.0&quot;

        // ViewModel
        implementation &quot;androidx.lifecycle:lifecycle-viewmodel:$lifecycle_version&quot;
        // LiveData
        implementation &quot;androidx.lifecycle:lifecycle-livedata:$lifecycle_version&quot;
        // Lifecycles only (without ViewModel or LiveData)
        implementation &quot;androidx.lifecycle:lifecycle-runtime:$lifecycle_version&quot;

        // Saved state module for ViewModel
        implementation &quot;androidx.lifecycle:lifecycle-viewmodel-savedstate:$lifecycle_version&quot;

        // Annotation processor
        annotationProcessor &quot;androidx.lifecycle:lifecycle-compiler:$lifecycle_version&quot;
        // alternately - if using Java8, use the following instead of lifecycle-compiler
        implementation &quot;androidx.lifecycle:lifecycle-common-java8:$lifecycle_version&quot;

        // optional - helpers for implementing LifecycleOwner in a Service
        implementation &quot;androidx.lifecycle:lifecycle-service:$lifecycle_version&quot;

        // optional - ProcessLifecycleOwner provides a lifecycle for the whole application process
        implementation &quot;androidx.lifecycle:lifecycle-process:$lifecycle_version&quot;

        // optional - ReactiveStreams support for LiveData
        implementation &quot;androidx.lifecycle:lifecycle-reactivestreams:$lifecycle_version&quot;

        // optional - Test helpers for LiveData
        testImplementation &quot;androidx.arch.core:core-testing:$arch_version&quot;
    }
    
</code></pre>
<h1 id="六-参考资料">六、参考资料</h1>
<p><a href="https://developer.android.google.cn/jetpack">Google Jetpack 官方文档</a></p>
<p><a href="https://www.imooc.com/u/index/read">慕课专栏：跟架构师学Jetpack</a></p>
<p>《Android Jetpack 应用指南》叶坤</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Jetpack 简介]]></title>
        <id>https://yancechen.github.io/post/jetpack-jian-jie/</id>
        <link href="https://yancechen.github.io/post/jetpack-jian-jie/">
        </link>
        <updated>2020-09-16T04:55:52.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-什么是-jetpack">一、什么是 Jetpack</h1>
<p>Jetpack 是一个丰富的组件库，它的组件库按类别分为 4 类，分别是架构（Architecture）、界面（UI）、行为（behavior）和基础（foundation）。每个组件都可以单独使用，也可以配合在一起使用。每个组件都给用户提供了一个标准，能够帮助开发者遵循最佳做法，减少样板代码并编写可在各种 Android 版本和设备中一致运行的代码，让开发者能够集中精力编写重要的业务代码。</p>
<figure data-type="image" tabindex="1"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba3329982141490d827ea059b2100a34~tplv-k3u1fbpfcp-zoom-1.image" alt="图1" loading="lazy"></figure>
<h1 id="二-jetpack-的优势">二、Jetpack 的优势</h1>
<h2 id="一解决了-android-架构问题">（一）解决了 Android 架构问题</h2>
<p>由于之前 Google 并没有推出关于 Android 应用程序架构设计的标准，因此，很多工程师只能自己创造各种解决方案，但这些方案都普遍存在两个问题：</p>
<ul>
<li>非 Google 官方解决方案</li>
</ul>
<p>一般有经验的工程师，都会从自己做过的项目中，总结出一套自己的架构设计，并且将其应用到生产环境中，不过或多或少的都会存在一定的问题，因此需要有人一直维护和持续优化项目的架构。并且随着项目需求复杂度的增加，也面临重新设计架构的工作。</p>
<ul>
<li>无法辨别最佳的解决方案</li>
</ul>
<p>由于每个工程师的设计思路都不相同，因此，也无法确认到底谁的架构是最佳方案，最终也导致了开发出来的应用参差不齐。</p>
<p>Google 也意识到了这些问题，因此推出了 Jetpack，让开发者能够使用标准的架构组件，而不用去纠结架构的方案设计，可以将更多的精力放在自己的业务代码上。</p>
<h2 id="二提升了代码质量">（二）提升了代码质量</h2>
<p>Jetpack 拥有基于生命周期感知的能力，可以减少 NPE 崩溃、内存泄漏。为我们开发出健壮且流畅的程序提供强力保障；</p>
<h2 id="三提升了开发效率">（三）提升了开发效率</h2>
<p>Jetpack 可以减少样板代码，有助于提升 Android 开发的效率。这些组件可以单独使用，也可以组合使用，并且在不同 Android 版本中运行一致。</p>
<h1 id="三-jetpack-与-androidx">三、Jetpack 与 AndroidX</h1>
<p>Jetpack 是各种组件库的统称，AndroidX 是这些组件的统一包名。</p>
<p>AndroidX 对原始 Android Support Library 进行了重大改进，后者现在已不再维护。androidx 软件包完全取代了 support 包，不仅提供同等的功能，而且提供了新的库。Jetpack 组件中也是完全使用 androidx 开头的包名。</p>
<p>与 Support Library 一样，androidx 命名空间中的库与 Android 平台分开提供，并向后兼容各个 Android 版本。</p>
<p><strong>注意：</strong></p>
<ul>
<li>
<p>AndroidX 中的所有软件包都使用一致的命名空间，以字符串 androidx 开头。Support Library 软件包已映射到对应的 androidx.* 软件包。</p>
</li>
<li>
<p>与 Support Library 不同，androidx 软件包会单独维护和更新。从版本 1.0.0 开始，androidx 软件包使用严格的语义版本控制。可以单独更新项目中的各个 AndroidX 库。</p>
</li>
<li>
<p>版本 28.0.0 是 Support Library 的最后一个版本。以后将不再发布 android.support 库版本。所有新功能都将在 androidx 命名空间中开发。</p>
</li>
</ul>
<h1 id="四-本文参考资料">四、本文参考资料</h1>
<p><a href="https://developer.android.google.cn/jetpack">Google Jetpack 官方文档</a></p>
<p><a href="https://www.imooc.com/u/index/read">慕课专栏：跟架构师学Jetpack</a></p>
<p>《Android Jetpack 应用指南》叶坤</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android 学习资料汇总]]></title>
        <id>https://yancechen.github.io/post/android-xue-xi-zi-liao-hui-zong/</id>
        <link href="https://yancechen.github.io/post/android-xue-xi-zi-liao-hui-zong/">
        </link>
        <updated>2020-07-09T06:38:13.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-webview">一、WebView</h3>
<p>来自 Carson_Ho 的文章</p>
<ol>
<li><a href="https://www.jianshu.com/p/d2d4f652029d">Android Hybrid开发：这是一份详细 &amp; 全面的WebView学习攻略</a></li>
<li><a href="https://www.jianshu.com/p/5e7075f4875f">Android：手把手教你构建 全面的WebView 缓存机制 &amp; 资源加载方案</a></li>
<li><a href="https://www.jianshu.com/p/345f4d8a5cfa">最全面总结 Android WebView与 JS 的交互方式</a></li>
<li><a href="https://www.jianshu.com/p/3a345d27cd42">你不知道的 Android WebView 使用漏洞</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常用网站]]></title>
        <id>https://yancechen.github.io/post/chang-yong-wang-zhan/</id>
        <link href="https://yancechen.github.io/post/chang-yong-wang-zhan/">
        </link>
        <updated>2020-06-09T03:16:39.000Z</updated>
        <summary type="html"><![CDATA[<p>常用网站梳理，方便访问</p>
]]></summary>
        <content type="html"><![CDATA[<p>常用网站梳理，方便访问</p>
<!-- more -->
<h3 id="一-github">一、github</h3>
<p>1.<a href="https://github.com/google">Google Open Source</a><br>
2.<a href="https://github.com/alibaba">Alibaba Open Source</a><br>
3.<a href="https://github.com/SmartisanTech">SmartisanTech</a><br>
4.<a href="https://github.com/Tencent">Tencent</a><br>
5.<a href="https://github.com/JakeWharton">Jake Wharton</a><br>
6.<a href="https://github.com/gradle">Gradle</a><br>
7.<a href="https://github.com/flutter">Flutter</a></p>
<h3 id="二-高质量社区和博客">二、高质量社区和博客</h3>
<p>1.<a href="https://wanandroid.com/">玩 Android</a><br>
2.<a href="https://blog.csdn.net/guolin_blog">郭霖的专栏CSDN</a><br>
3.<a href="http://liuwangshu.cn/">刘望舒的博客</a><br>
4.<a href="https://blog.csdn.net/carson_ho">carson_ho 专注分享 Android开发 干货</a></p>
<h3 id="三-flutter-学习">三、Flutter 学习</h3>
<p>1.<a href="https://flutter.cn/docs">Flutter 官方开发文档-中文版</a><br>
2.<a href="https://github.com/flutter">Flutter 的 Github</a><br>
3.<a href="https://flutterchina.club/">国内 Flutter 中文网</a><br>
4.<a href="https://pub.dev/">Flutter Pub仓库</a><br>
5.<a href="https://dartpad.cn/">Dartpad</a><br>
6.<a href="https://blog.csdn.net/mengks1987">老孟Flutter</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android Studio for mac 快捷键设置]]></title>
        <id>https://yancechen.github.io/post/android-studio-for-mac-kuai-jie-jian-she-zhi/</id>
        <link href="https://yancechen.github.io/post/android-studio-for-mac-kuai-jie-jian-she-zhi/">
        </link>
        <updated>2020-06-08T06:52:51.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1左键查看源码总弹出右键菜单">1.左键查看源码，总弹出右键菜单</h3>
<p>在mac中使用 Android studio，需要进入某一个类，或者查看调用的方法时，要使用ctrl＋左键来进入，但是这个又是系统右键的快捷键，所以我们需要覆盖一下快捷键的设置。</p>
<p>KeyMap 中搜索 Declaration，点击 Add Mouse Shortcut，添加 cmd+左键，即可完成覆盖，以后再也不会弹出右键的提示了。</p>
<figure data-type="image" tabindex="1"><img src="https://yancechen.github.io/post-images/1591599326422.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Flutter 学习资料汇总]]></title>
        <id>https://yancechen.github.io/post/flutter-xue-xi-zi-liao-hui-zong/</id>
        <link href="https://yancechen.github.io/post/flutter-xue-xi-zi-liao-hui-zong/">
        </link>
        <updated>2020-06-08T02:41:08.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-flutter-官网">一、Flutter 官网</h3>
<p><a href="https://flutter.cn/docs">Flutter 官方中文网</a></p>
<h3 id="二-入门">二、入门</h3>
<p>1.<a href="https://www.jianshu.com/p/0a19cf96dbe3">Android跨平台：请收好这份快速入门Flutter的学习指南！</a><br>
2.<a href="https://cn.udacity.com/course/build-native-mobile-apps-with-flutter--ud905">Build Native Mobile Apps with Flutter</a></p>
]]></content>
    </entry>
</feed>