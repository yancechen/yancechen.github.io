<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yancechen.github.io</id>
    <title>陈有余</title>
    <updated>2020-09-16T12:22:06.566Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yancechen.github.io"/>
    <link rel="self" href="https://yancechen.github.io/atom.xml"/>
    <subtitle>万物之中，希望至美</subtitle>
    <logo>https://yancechen.github.io/images/avatar.png</logo>
    <icon>https://yancechen.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 陈有余</rights>
    <entry>
        <title type="html"><![CDATA[Jetpack 之 LifeCycle 组件使用详解]]></title>
        <id>https://yancechen.github.io/post/jetpack-zhi-lifecycle-zu-jian-shi-yong-xiang-jie/</id>
        <link href="https://yancechen.github.io/post/jetpack-zhi-lifecycle-zu-jian-shi-yong-xiang-jie/">
        </link>
        <updated>2020-09-16T04:56:29.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-lifecycle-简介">一、LifeCycle 简介</h1>
<p>LifeCycle 是一个可以感知宿主生命周期变化的组件。常见的宿主包括 Activity/Fragment、Service 和 Application。LifeCycle 会持有宿主的生命周期状态的信息，当宿主生命周期发生变化时，会通知监听宿主的观察者。</p>
<p><strong>LifeCycle 的出现主要是为了解决：</strong> 系统组件的生命周期与普通组件之间的耦合性。</p>
<ul>
<li>系统组件指：Activity/Fragment、Service 和 Application。</li>
<li>普通组件指：将代码按照功能或者作用封装成的组件。</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd01ec517e5f4438bc618649435fe90f~tplv-k3u1fbpfcp-zoom-1.image" alt="LifeCycle 的原理" loading="lazy"></figure>
<p>哪些情况下，系统组件的生命周期会和普通组件的生命周期耦合在一起呢？</p>
<p><strong>举个栗子：</strong></p>
<p>在 58 部落业务中有视频播放的业务需求。我们需要在 Activity 中对视频播放组件进行初始化，在 onPause() 方法中停止视频的播放，在 onDestroy() 方法中对视频播放组件以及一些资源进行回收。这样的做法非常繁琐，会让页面与组件之间的耦合度变高。</p>
<p>对于这类问题，完全可以使用 LifeCycle 来解决。<strong>它不仅降低了模块之间的耦合度，还降低了内存泄露发生的可能性</strong>。</p>
<h1 id="二-lifecycle-的使用">二、LifeCycle 的使用</h1>
<p>Jetpack 为我们提供了两个接口：</p>
<p>被观察者：<code>LifecycleOwner</code></p>
<p>观察者：<code>LifecycleObserver</code></p>
<p>被监听的系统组件需要去实现 LifecycleOwner 接口，观察者需要实现 LifecycleObserver 接口。</p>
<h2 id="一使用场景1使用-lifecycle-解耦页面与组件">（一）使用场景1：使用 LifeCycle 解耦页面与组件</h2>
<h3 id="1解耦-activity">（1）解耦 Activity</h3>
<h4 id="第一步添加依赖">第一步：添加依赖</h4>
<pre><code class="language-groovy">implementation 'androidx.appcompat:appcompat:1.2.0'
</code></pre>
<p>在 AndroidX 里面 ComponentActivity 已经默认实现了 LifecycleOwner 接口。如果项目没有迁移到 AndroidX，还是用的 Support 库，新版本的 SDK 也通过 SupportActivity 实现了 LifecycleOwner 接口。</p>
<figure data-type="image" tabindex="2"><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6997c541919b4c61b6fd5c0a26c985e2~tplv-k3u1fbpfcp-zoom-1.image" alt="" loading="lazy"></figure>
<p>在 LifecycleOwner 接口中，只有一个 getLifecycle 方法。</p>
<h4 id="第二步实现观察者">第二步：实现观察者</h4>
<p>如果是想监听某个 Activity 的生命周期，需要我们做的就是自定义组件，实现 LifecycleObserver 接口即可，该接口没有接口方法，不需要任何具体的实现。</p>
<p>比如以刚刚的视频播放为例：</p>
<ol>
<li>创建一个 MyVideoPlayListener 类，实现 LifecycleObserver 接口，与视频播放相关的逻辑全在这个类里面完成。对于组件里面需要在 Activity 生命周期变化时得到通知的方法，用 @OnLifecycleEvent(Lifecycle.Event.ON_XXX) 注解进行标记，这样当 Activity 生命周期发生变化时，被标记过的方法便会被自动调用。</li>
</ol>
<pre><code class="language-java">public class MyVideoPlayListener implements LifecycleObserver {
    private static String TAG = &quot;MyVideoPlayListener&quot;;

    @OnLifecycleEvent(Lifecycle.Event.ON_CREATE)
    private void initVideo(){
        Log.d(TAG,&quot;initVideo&quot;);
    }

    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)
    private void startPlay(){
        Log.d(TAG,&quot;startPlay&quot;);
    }

    @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)
    private void pausePlay(){
        Log.d(TAG,&quot;pausePlay&quot;);
    }
}
</code></pre>
<p>2.在 MainActivity 中对 MyVideoPlayListener 进行引用即可。</p>
<pre><code class="language-java">public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        MyVideoPlayListener listener = new MyVideoPlayListener();
        getLifecycle().addObserver(listener);
    }
}
</code></pre>
<h3 id="2解耦-fragment">（2）解耦 Fragment</h3>
<p>在新版的 SDK 中，Fragment 同样也默认实现了 LifecycleOwner 接口，因此，以上的例子同样适合于 Fragment。</p>
<h2 id="二使用场景2使用-lifecycleservice-解耦-service-与组件">（二）使用场景2：使用 LifecycleService 解耦 Service 与组件</h2>
<h3 id="1lifecycleservice-基本介绍">（1）LifecycleService 基本介绍</h3>
<p>Android 中拥有生命周期的组件除了 Activity/Fragment ，还有一个非常重要的组件就是 Service。LifecycleService 就是用来监听和解耦 Service 组件的。</p>
<pre><code class="language-java">public class LifecycleService extends Service implements LifecycleOwner {

    private final ServiceLifecycleDispatcher mDispatcher = new ServiceLifecycleDispatcher(this);

    ......

    @Override
    @NonNull
    public Lifecycle getLifecycle() {
        return mDispatcher.getLifecycle();
    }
}
</code></pre>
<h3 id="2具体使用方法">（2）具体使用方法</h3>
<h4 id="第一步添加相关依赖">第一步：添加相关依赖</h4>
<pre><code class="language-groovy">implementation &quot;androidx.lifecycle:lifecycle-service:2.2.0&quot;
</code></pre>
<h4 id="第二步创建-myserviceobserver-类实现-lifecycleobserver-接口-使用-onlifecycleevent-标记希望在-server-生命周期发生变化时得到同步调用的方法">第二步：创建 MyServiceObserver 类，实现 LifecycleObserver 接口。使用 @OnLifecycleEvent 标记希望在 Server 生命周期发生变化时得到同步调用的方法。</h4>
<pre><code class="language-java">public class MyServiceObserver implements LifecycleObserver {
    private static String TAG = &quot;MyServiceObserver&quot;;

    @OnLifecycleEvent(Lifecycle.Event.ON_CREATE)
    private void initVideo(){
        Log.d(TAG,&quot;initVideo&quot;);
    }

    @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)
    private void pausePlay(){
        Log.d(TAG,&quot;stopPlay&quot;);
    }
}
</code></pre>
<h4 id="第三步创建一个-myservice-的类继承-lifecycleservice-由于-lifecycleservice-是-service-的直接子类所以使用起来与普通的-service-没有差别">第三步：创建一个 MyService 的类，继承 LifecycleService。由于 LifecycleService 是 Service 的直接子类，所以使用起来与普通的 Service 没有差别。</h4>
<pre><code class="language-java">public class MyService extends LifecycleService {
    private MyServiceObserver myServiceObserver;
    
    public MyService(){
        myServiceObserver = new MyServiceObserver();
        getLifecycle().addObserver(myServiceObserver);
    }
}
</code></pre>
<h2 id="三使用场景3使用-processlifecycleowner-监听应用程序的生命周期">（三）使用场景3：使用 ProcessLifecycleOwner 监听应用程序的生命周期</h2>
<p>具有生命周期的组件除了 Activity、Fragment 和 Service 外，还有 Application。ProcessLifecycleOwner 就是用来监听整个应用程序的生命周期情况。</p>
<p>具体使用方法：</p>
<h4 id="第一步添加依赖项">第一步：添加依赖项</h4>
<pre><code class="language-groovy">implementation &quot;androidx.lifecycle:lifecycle-process:2.2.0&quot;
</code></pre>
<h4 id="第二步定义一个-applicationobserver实现-lifecycleobserver-接口">第二步：定义一个 ApplicationObserver，实现 LifecycleObserver 接口。</h4>
<pre><code class="language-java">public class ApplicationObserver implements LifecycleObserver {
    private String TAG = this.getClass().getName();

    /**
     * 在应用程序的整个生命周期中只会被调用一次
     */
    @OnLifecycleEvent(Lifecycle.Event.ON_CREATE)
    public void onCreate() {
        Log.d(TAG,&quot;Lifecycle.Event.ON_CREATE&quot;);
    }

    @OnLifecycleEvent(Lifecycle.Event.ON_START)
    public void onStart() {
        Log.d(TAG,&quot;Lifecycle.Event.ON_START&quot;);
    }

    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)
    public void onResume() {
        Log.d(TAG,&quot;Lifecycle.Event.ON_RESUME&quot;);
    }

    @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)
    public void onPause() {
        Log.d(TAG,&quot;Lifecycle.Event.ON_PAUSE&quot;);
    }

    @OnLifecycleEvent(Lifecycle.Event.ON_STOP)
    public void onStop() {
        Log.d(TAG,&quot;Lifecycle.Event.ON_STOP&quot;);
    }

    /**
     * 永远不会被调用，系统不会分发调用 ON_DESTROY 事件
     */
    @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)
    public void onDestroy() {
        Log.d(TAG,&quot;Lifecycle.Event.ON_DESTROY&quot;);
    }
}
</code></pre>
<h4 id="第三步在-application-中关联-applicationobserver">第三步：在 Application 中关联 ApplicationObserver。</h4>
<pre><code class="language-java">public class App extends Application {
    @Override
    public void onCreate() {
        super.onCreate();
        ProcessLifecycleOwner.get().getLifecycle().addObserver(new ApplicationObserver());
    }
}
</code></pre>
<p><strong>注意事项：</strong></p>
<ol>
<li>ProcessLifecycleOwner 是针对整个应用程序的监听，与 Activity 的数量无关。</li>
<li>Lifecycle.Event.ON_CREATE 只会被调用一次，而 Lifecycle.Event.ON_DESTROY 永远不会被调用。</li>
<li>Lifecycle.Event.ON_PAUSE 和 Lifecycle.Event.ON_STOP 的调用会有一定的延后，因为系统需要为“屏幕旋转，由于配置发生变化而导致的 Activity 重新创建” 的情况预留一些时间。</li>
</ol>
<h1 id="三-lifecycle-的另外两种写法">三、Lifecycle 的另外两种写法</h1>
<p>Lifecycle 有三种实现方法：</p>
<ol>
<li>LifecycleObserver 配合注解</li>
<li>FullLifecyclerObserver 拥有宿主所有生命周期事件</li>
<li>LifecycleEventObserver宿主生命周期事件封装成 Lifecycle.Event</li>
</ol>
<p>在上一节使用介绍中，我们用的是第一种方式：LifecycleObserver 配合注解。</p>
<p>这种方式使用比较简单，但是注意最好添加 lifecycle-compiler 这个注解处理器，否者在运行时会使用反射的形式回调到对应的方法上：</p>
<pre><code class="language-groovy">annotationProcessor &quot;androidx.lifecycle:lifecycle-compiler:2.2.0&quot;
</code></pre>
<p>加上这个注解处理器后，用 <code>@OnLifecycleEvent</code> 标记的方法就不能再声明成 <code>private</code> ，否者会报如下的错误：</p>
<pre><code class="language-java">method marked with OnLifecycleEvent annotation can not be private
</code></pre>
<p>下面介绍一下另外两种实现方式：</p>
<h2 id="一fulllifecyclerobserver-拥有宿主所有生命周期事件">（一）FullLifecyclerObserver 拥有宿主所有生命周期事件</h2>
<pre><code class="language-java">//该接口中定义好了生命周期方法，我们只需要实现 FullLifecycleObserver 接口，重写对应的
//生命周期方法即可。不过目前 FullLifecycleObserver 这个接口未开放给开发者使用。
interface FullLifecycleObserver extends LifecycleObserver {

    void onCreate(LifecycleOwner owner);

    void onStart(LifecycleOwner owner);

    void onResume(LifecycleOwner owner);

    void onPause(LifecycleOwner owner);

    void onStop(LifecycleOwner owner);

    void onDestroy(LifecycleOwner owner);
}
</code></pre>
<h2 id="二lifecycleeventobserver-宿主生命周期事件封装成-lifecycleevent">（二）LifecycleEventObserver 宿主生命周期事件封装成 Lifecycle.Event</h2>
<pre><code class="language-java">//通过实现 LifecycleEventObserver 接口，重写 onStateChanged 方法，在该方法内部
//通过判断 Lifecycle.Event 来实现具体的业务逻辑
public class MyVideoPlayObserver implements LifecycleEventObserver {
    private static String TAG = &quot;MyVideoPlayObserver&quot;;

    @Override
    public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event) {
        switch (event){
            case ON_CREATE:
                Log.d(TAG,&quot;initVideo&quot;);
                break;
            case ON_START:
                Log.d(TAG,&quot;startPlay&quot;);
                break;
            case ON_RESUME:
                Log.d(TAG,&quot;resumePlay&quot;);
                break;
            default:
                 break;
        }
    }
}
</code></pre>
<h1 id="四-总结">四、总结</h1>
<p><strong>LifeCycle 组件存在的主要意义是帮助我们解耦，让自己定义的组件也能够感受到生命周期的变化。</strong></p>
<h1 id="五-补充">五、补充</h1>
<p>截止本文发布时，lifecycle_version 最新版本是 <code>2.2.0</code>，如需获取最新版本请查看官网：</p>
<p>https://developer.android.google.cn/jetpack/androidx/releases/lifecycle</p>
<p>注：<code>lifecycle-extensions</code> 中的 API 已弃用，需要使用到 Lifecycle 下的某个工具时，添加对应的依赖即可：</p>
<pre><code class="language-groovy">    dependencies {
        def lifecycle_version = &quot;2.2.0&quot;
        def arch_version = &quot;2.1.0&quot;

        // ViewModel
        implementation &quot;androidx.lifecycle:lifecycle-viewmodel:$lifecycle_version&quot;
        // LiveData
        implementation &quot;androidx.lifecycle:lifecycle-livedata:$lifecycle_version&quot;
        // Lifecycles only (without ViewModel or LiveData)
        implementation &quot;androidx.lifecycle:lifecycle-runtime:$lifecycle_version&quot;

        // Saved state module for ViewModel
        implementation &quot;androidx.lifecycle:lifecycle-viewmodel-savedstate:$lifecycle_version&quot;

        // Annotation processor
        annotationProcessor &quot;androidx.lifecycle:lifecycle-compiler:$lifecycle_version&quot;
        // alternately - if using Java8, use the following instead of lifecycle-compiler
        implementation &quot;androidx.lifecycle:lifecycle-common-java8:$lifecycle_version&quot;

        // optional - helpers for implementing LifecycleOwner in a Service
        implementation &quot;androidx.lifecycle:lifecycle-service:$lifecycle_version&quot;

        // optional - ProcessLifecycleOwner provides a lifecycle for the whole application process
        implementation &quot;androidx.lifecycle:lifecycle-process:$lifecycle_version&quot;

        // optional - ReactiveStreams support for LiveData
        implementation &quot;androidx.lifecycle:lifecycle-reactivestreams:$lifecycle_version&quot;

        // optional - Test helpers for LiveData
        testImplementation &quot;androidx.arch.core:core-testing:$arch_version&quot;
    }
    
</code></pre>
<h1 id="六-参考资料">六、参考资料</h1>
<p><a href="https://developer.android.google.cn/jetpack">Google Jetpack 官方文档</a></p>
<p><a href="https://www.imooc.com/u/index/read">慕课专栏：跟架构师学Jetpack</a></p>
<p>《Android Jetpack 应用指南》叶坤</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Jetpack 简介]]></title>
        <id>https://yancechen.github.io/post/jetpack-jian-jie/</id>
        <link href="https://yancechen.github.io/post/jetpack-jian-jie/">
        </link>
        <updated>2020-09-16T04:55:52.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-什么是-jetpack">一、什么是 Jetpack</h1>
<p>Jetpack 是一个丰富的组件库，它的组件库按类别分为 4 类，分别是架构（Architecture）、界面（UI）、行为（behavior）和基础（foundation）。每个组件都可以单独使用，也可以配合在一起使用。每个组件都给用户提供了一个标准，能够帮助开发者遵循最佳做法，减少样板代码并编写可在各种 Android 版本和设备中一致运行的代码，让开发者能够集中精力编写重要的业务代码。</p>
<figure data-type="image" tabindex="1"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba3329982141490d827ea059b2100a34~tplv-k3u1fbpfcp-zoom-1.image" alt="图1" loading="lazy"></figure>
<h1 id="二-jetpack-的优势">二、Jetpack 的优势</h1>
<h2 id="一解决了-android-架构问题">（一）解决了 Android 架构问题</h2>
<p>由于之前 Google 并没有推出关于 Android 应用程序架构设计的标准，因此，很多工程师只能自己创造各种解决方案，但这些方案都普遍存在两个问题：</p>
<ul>
<li>非 Google 官方解决方案</li>
</ul>
<p>一般有经验的工程师，都会从自己做过的项目中，总结出一套自己的架构设计，并且将其应用到生产环境中，不过或多或少的都会存在一定的问题，因此需要有人一直维护和持续优化项目的架构。并且随着项目需求复杂度的增加，也面临重新设计架构的工作。</p>
<ul>
<li>无法辨别最佳的解决方案</li>
</ul>
<p>由于每个工程师的设计思路都不相同，因此，也无法确认到底谁的架构是最佳方案，最终也导致了开发出来的应用参差不齐。</p>
<p>Google 也意识到了这些问题，因此推出了 Jetpack，让开发者能够使用标准的架构组件，而不用去纠结架构的方案设计，可以将更多的精力放在自己的业务代码上。</p>
<h2 id="二提升了代码质量">（二）提升了代码质量</h2>
<p>Jetpack 拥有基于生命周期感知的能力，可以减少 NPE 崩溃、内存泄漏。为我们开发出健壮且流畅的程序提供强力保障；</p>
<h2 id="三提升了开发效率">（三）提升了开发效率</h2>
<p>Jetpack 可以减少样板代码，有助于提升 Android 开发的效率。这些组件可以单独使用，也可以组合使用，并且在不同 Android 版本中运行一致。</p>
<h1 id="三-jetpack-与-androidx">三、Jetpack 与 AndroidX</h1>
<p>Jetpack 是各种组件库的统称，AndroidX 是这些组件的统一包名。</p>
<p>AndroidX 对原始 Android Support Library 进行了重大改进，后者现在已不再维护。androidx 软件包完全取代了 support 包，不仅提供同等的功能，而且提供了新的库。Jetpack 组件中也是完全使用 androidx 开头的包名。</p>
<p>与 Support Library 一样，androidx 命名空间中的库与 Android 平台分开提供，并向后兼容各个 Android 版本。</p>
<p><strong>注意：</strong></p>
<ul>
<li>
<p>AndroidX 中的所有软件包都使用一致的命名空间，以字符串 androidx 开头。Support Library 软件包已映射到对应的 androidx.* 软件包。</p>
</li>
<li>
<p>与 Support Library 不同，androidx 软件包会单独维护和更新。从版本 1.0.0 开始，androidx 软件包使用严格的语义版本控制。可以单独更新项目中的各个 AndroidX 库。</p>
</li>
<li>
<p>版本 28.0.0 是 Support Library 的最后一个版本。以后将不再发布 android.support 库版本。所有新功能都将在 androidx 命名空间中开发。</p>
</li>
</ul>
<h1 id="四-本文参考资料">四、本文参考资料</h1>
<p><a href="https://developer.android.google.cn/jetpack">Google Jetpack 官方文档</a></p>
<p><a href="https://www.imooc.com/u/index/read">慕课专栏：跟架构师学Jetpack</a></p>
<p>《Android Jetpack 应用指南》叶坤</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android 学习资料汇总]]></title>
        <id>https://yancechen.github.io/post/android-xue-xi-zi-liao-hui-zong/</id>
        <link href="https://yancechen.github.io/post/android-xue-xi-zi-liao-hui-zong/">
        </link>
        <updated>2020-07-09T06:38:13.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-webview">一、WebView</h3>
<p>来自 Carson_Ho 的文章</p>
<ol>
<li><a href="https://www.jianshu.com/p/d2d4f652029d">Android Hybrid开发：这是一份详细 &amp; 全面的WebView学习攻略</a></li>
<li><a href="https://www.jianshu.com/p/5e7075f4875f">Android：手把手教你构建 全面的WebView 缓存机制 &amp; 资源加载方案</a></li>
<li><a href="https://www.jianshu.com/p/345f4d8a5cfa">最全面总结 Android WebView与 JS 的交互方式</a></li>
<li><a href="https://www.jianshu.com/p/3a345d27cd42">你不知道的 Android WebView 使用漏洞</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常用网站]]></title>
        <id>https://yancechen.github.io/post/chang-yong-wang-zhan/</id>
        <link href="https://yancechen.github.io/post/chang-yong-wang-zhan/">
        </link>
        <updated>2020-06-09T03:16:39.000Z</updated>
        <summary type="html"><![CDATA[<p>常用网站梳理，方便访问</p>
]]></summary>
        <content type="html"><![CDATA[<p>常用网站梳理，方便访问</p>
<!-- more -->
<h3 id="一-github">一、github</h3>
<p>1.<a href="https://github.com/google">Google Open Source</a><br>
2.<a href="https://github.com/alibaba">Alibaba Open Source</a><br>
3.<a href="https://github.com/SmartisanTech">SmartisanTech</a><br>
4.<a href="https://github.com/Tencent">Tencent</a><br>
5.<a href="https://github.com/JakeWharton">Jake Wharton</a><br>
6.<a href="https://github.com/gradle">Gradle</a><br>
7.<a href="https://github.com/flutter">Flutter</a></p>
<h3 id="二-高质量社区和博客">二、高质量社区和博客</h3>
<p>1.<a href="https://wanandroid.com/">玩 Android</a><br>
2.<a href="https://blog.csdn.net/guolin_blog">郭霖的专栏CSDN</a><br>
3.<a href="http://liuwangshu.cn/">刘望舒的博客</a><br>
4.<a href="https://blog.csdn.net/carson_ho">carson_ho 专注分享 Android开发 干货</a></p>
<h3 id="三-flutter-学习">三、Flutter 学习</h3>
<p>1.<a href="https://flutter.cn/docs">Flutter 官方开发文档-中文版</a><br>
2.<a href="https://github.com/flutter">Flutter 的 Github</a><br>
3.<a href="https://flutterchina.club/">国内 Flutter 中文网</a><br>
4.<a href="https://pub.dev/">Flutter Pub仓库</a><br>
5.<a href="https://dartpad.cn/">Dartpad</a><br>
6.<a href="https://blog.csdn.net/mengks1987">老孟Flutter</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android Studio for mac 快捷键设置]]></title>
        <id>https://yancechen.github.io/post/android-studio-for-mac-kuai-jie-jian-she-zhi/</id>
        <link href="https://yancechen.github.io/post/android-studio-for-mac-kuai-jie-jian-she-zhi/">
        </link>
        <updated>2020-06-08T06:52:51.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1左键查看源码总弹出右键菜单">1.左键查看源码，总弹出右键菜单</h3>
<p>在mac中使用 Android studio，需要进入某一个类，或者查看调用的方法时，要使用ctrl＋左键来进入，但是这个又是系统右键的快捷键，所以我们需要覆盖一下快捷键的设置。</p>
<p>KeyMap 中搜索 Declaration，点击 Add Mouse Shortcut，添加 cmd+左键，即可完成覆盖，以后再也不会弹出右键的提示了。</p>
<figure data-type="image" tabindex="1"><img src="https://yancechen.github.io/post-images/1591599326422.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Flutter 学习资料汇总]]></title>
        <id>https://yancechen.github.io/post/flutter-xue-xi-zi-liao-hui-zong/</id>
        <link href="https://yancechen.github.io/post/flutter-xue-xi-zi-liao-hui-zong/">
        </link>
        <updated>2020-06-08T02:41:08.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-flutter-官网">一、Flutter 官网</h3>
<p><a href="https://flutter.cn/docs">Flutter 官方中文网</a></p>
<h3 id="二-入门">二、入门</h3>
<p>1.<a href="https://www.jianshu.com/p/0a19cf96dbe3">Android跨平台：请收好这份快速入门Flutter的学习指南！</a><br>
2.<a href="https://cn.udacity.com/course/build-native-mobile-apps-with-flutter--ud905">Build Native Mobile Apps with Flutter</a></p>
]]></content>
    </entry>
</feed>